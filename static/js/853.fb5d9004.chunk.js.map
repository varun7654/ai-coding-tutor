{"version":3,"file":"static/js/853.fb5d9004.chunk.js","mappings":"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","sources":["problem/ProblemParse.ts","problem/Help.tsx","problem/CodeRunner.ts","problem/Problem.tsx"],"sourcesContent":["import {marked} from \"./Problem\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\nexport class ProblemData {\r\n    id: string = \"\";\r\n    title: string = 'Loading...';\r\n    preProblemDescription: string = \"\";\r\n    description: string = \"\";\r\n    tests: TestCase[] = [];\r\n    hiddenTests: TestCase[] = [];\r\n    displayAbove: string = \"\";\r\n    displayBelow: string = \"\";\r\n    solution: string = \"\";\r\n    solutionCode: string = \"\";\r\n    codeLang: string = \"\";\r\n    nextProblemId: string = \"\";\r\n}\r\n\r\nexport class TestCase {\r\n    test: string;\r\n    display: string;\r\n    magicLinks: KeyValue[];\r\n\r\n    constructor(test: string, display: string, magicLinks: KeyValue[]) {\r\n        this.test = test;\r\n        this.display = display;\r\n        this.magicLinks = magicLinks;\r\n    }\r\n}\r\n\r\nexport class KeyValue {\r\n    key: string;\r\n    value: string;\r\n\r\n    constructor(key: string, value: string) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nexport function parseProblem(text: string, id: string): ProblemData {\r\n    let tokens = marked.lexer(text);\r\n    let title = (tokens.shift() as Tokens.Heading).text;\r\n\r\n    let preProblemDescription = \"\";\r\n    removeTillNextType(tokens, \"heading\"); // Collect everything under the description heading\r\n    if ((tokens[0] as Tokens.Heading).text === \"Context\") {\r\n        tokens.shift();\r\n        while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n            preProblemDescription += ((tokens.shift() as Token).raw);\r\n        }\r\n    }\r\n\r\n    // Collect everything under the description heading\r\n    removeNextHeading(tokens, \"description\"); // Remove the description heading\r\n\r\n    let description = \"\";\r\n    while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n        description += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Problem\"); // Remove the problem heading\r\n    if (tokens[0].type !== \"code\") {\r\n        console.error(\"Problem Parse: No code block found after problem heading. If no template code is needed, please use a code block with no content (with the correct language).\");\r\n    }\r\n    let problem = tokens.shift() as Tokens.Code;\r\n    if (!problem.lang) {\r\n        console.error(\"Problem Parse: No code language specified for problem \" + id);\r\n    }\r\n    let codeLang = problem.lang ? problem.lang : \"javascript\";\r\n\r\n    let splitProblem = problem.text.split(\"// Your code here\");\r\n\r\n    let displayAbove;\r\n    let displayBelow;\r\n\r\n    if (splitProblem.length === 0 || splitProblem[0].trim() === \"\") {\r\n        console.log(\"Problem Parse: Code block has no content\");\r\n        displayAbove = \"\";\r\n        displayBelow = \"\";\r\n    } else {\r\n        displayAbove = splitProblem[0].trim();\r\n        if (splitProblem.length === 1) {\r\n            displayBelow = \"\";\r\n            console.error(\"Problem Parse: No secondary display content found in problem \" + id +\r\n                \". It is unlikely that this is intentional. Ensure that you have a comment with the text '// Your code here' in the problem description.\");\r\n        } else {\r\n            displayBelow = splitProblem[1].trim();\r\n        }\r\n    }\r\n\r\n\r\n    removeNextHeading(tokens, \"Solution\"); // Remove the solution heading\r\n    absorbWhitespace(tokens);\r\n    let solution = \"\";\r\n    let solutionCode = \"\";\r\n    while (tokens.length > 0 && !(tokens[0].type === \"heading\" && (tokens[0] as Tokens.Heading).depth <= 1)) {\r\n        if (tokens[0].type === \"code\" && solutionCode === \"\") {\r\n            // Get the first code block as the solution code\r\n            solutionCode += (tokens[0] as Tokens.Code).text;\r\n        }\r\n        solution += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Test Cases\"); // Remove the tests heading\r\n    let tests: TestCase[] = [];\r\n    extractTestCases(tokens, tests);\r\n\r\n    removeNextHeading(tokens, \"Hidden Test Cases\"); // Remove the hidden tests heading\r\n    let hiddenTests: TestCase[] = [];\r\n    extractTestCases(tokens, hiddenTests);\r\n\r\n    removeNextHeading(tokens, \"Next\");\r\n    let nextProblemId;\r\n    if (tokens.length === 0 || tokens[0].type !== \"paragraph\") {\r\n        nextProblemId = \"nothing\";\r\n    } else {\r\n        nextProblemId = (tokens.shift() as Tokens.Paragraph).text;\r\n        nextProblemId = nextProblemId.trim();\r\n        if (nextProblemId.startsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(1);\r\n        }\r\n        if (nextProblemId.endsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(0, nextProblemId.length - 1);\r\n        }\r\n        if (nextProblemId === \"\") {\r\n            nextProblemId = \"nothing\";\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        id,\r\n        title,\r\n        preProblemDescription,\r\n        description,\r\n        tests,\r\n        hiddenTests,\r\n        displayAbove,\r\n        displayBelow,\r\n        solution,\r\n        solutionCode,\r\n        codeLang,\r\n        nextProblemId\r\n    };\r\n}\r\n\r\nfunction extractTestCases(tokens: Token[], tests: TestCase[]) {\r\n    // Tests are formatted as a list of functions in a code block with the expected result below it\r\n    while (tokens.length > 0) {\r\n        absorbWhitespace(tokens);\r\n        if (tokens.length === 0 || tokens[0].type !== \"code\") break;\r\n        let test = tokens.shift() as Tokens.Code;\r\n\r\n        let testString = test.text.trim();\r\n        let split = testString.split(\"\\n\").flatMap((s) => s.trim());\r\n        let functionCall = split[split.length - 1];\r\n        let indexBeginParen = functionCall.indexOf(\"(\");\r\n        let indexEndParen = -1;\r\n        for (let i = functionCall.length - 1; i >= 0; i--) {\r\n            if (functionCall[i] === \")\") {\r\n                indexEndParen = i;\r\n                break;\r\n            }\r\n        }\r\n        if (indexBeginParen === -1 || indexEndParen === -1) {\r\n            console.error(\"Failed to parse function call (Magic Links will not work!): \" + functionCall);\r\n            continue;\r\n        }\r\n        let params = functionCall.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n        absorbWhitespace(tokens);\r\n        let repeatTimes = 1;\r\n        let displayAs = functionCall;\r\n        // Remove the last ; if it exists\r\n        if (displayAs.endsWith(\";\")) {\r\n            displayAs = displayAs.substring(0, displayAs.length - 1);\r\n        }\r\n\r\n        let magicLinks: KeyValue[] = [];\r\n\r\n        for (let param of params) {\r\n            // See if we can find where the parameter is defined in the code block\r\n            // We want to match let param = value;\r\n            let match = testString.match(new RegExp(`let\\\\s+${param}\\\\s*=\\\\s*`));\r\n            if (match !== null && match.index !== undefined) {\r\n                let value = testString.substring(match.index + match[0].length).trim();\r\n                let bracketCount = 0;\r\n                let curlyCount = 0;\r\n                let doubleQuoteCount = 0;\r\n                let singleQuoteCount = 0;\r\n                let backtickCount = 0;\r\n                for (let i = 0; i < value.length; i++) {\r\n                    let c = value[i];\r\n                    if (c === \"(\") {\r\n                        bracketCount++;\r\n                    } else if (c === \")\") {\r\n                        bracketCount--;\r\n                    } else if (c === \"{\") {\r\n                        curlyCount++;\r\n                    } else if (c === \"}\") {\r\n                        curlyCount--;\r\n                    } else if (c === \"\\\"\") {\r\n                        doubleQuoteCount++;\r\n                    } else if (c === \"'\") {\r\n                        singleQuoteCount++;\r\n                    } else if (c === \"`\") {\r\n                        backtickCount++;\r\n                    }\r\n                    if (bracketCount === 0 && curlyCount === 0 && doubleQuoteCount % 2 === 0 && singleQuoteCount % 2 === 0 && backtickCount % 2 === 0 && c === \";\" && i !== value.length - 1) {\r\n                        value = value.substring(0, i);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                setKeyValue(magicLinks, param, value);\r\n            }\r\n        }\r\n\r\n        // @ts-ignore - ts seems to not believe that type could be paragraph\r\n        while (tokens.length > 0 && tokens[0].type === \"paragraph\") {\r\n            let metaData = (tokens.shift() as Tokens.Paragraph).text.trim();\r\n\r\n            let split = metaData.split(\"=\").map(s => s.trim());\r\n            if (split.length !== 2) {\r\n                console.error(\"Failed to parse metadata: \" + metaData);\r\n                continue;\r\n            }\r\n            let key = split[0].toLowerCase();\r\n            let value = split[1];\r\n\r\n            if (key === \"repeat\") {\r\n                let num = parseInt(value);\r\n                if (isNaN(num)) {\r\n                    console.error(\"Failed to parse repeat value: \" + value);\r\n                } else {\r\n                    repeatTimes = num;\r\n                }\r\n            } else if (key === \"displayas\") {\r\n                displayAs = value;\r\n\r\n                let indexBeginParen = functionCall.indexOf(\"(\");\r\n                let indexEndParen = -1;\r\n                for (let i = displayAs.length - 1; i >= 0; i--) {\r\n                    if (displayAs[i] === \")\") {\r\n                        indexEndParen = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (indexBeginParen === -1 || indexEndParen === -1) {\r\n                    console.error(\"Failed to parse function for displayAs meta call (Magic Links will not work!): \" + displayAs);\r\n                    continue;\r\n                }\r\n                params = displayAs.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n            } else if (params.includes(split[0])) { // We don't want to remove the casing\r\n                let key = split[0];\r\n                let value = split[1];\r\n                if (split[1].length === 0) {\r\n                    // We should look for a code block\r\n                    absorbWhitespace(tokens);\r\n                    if (tokens.length === 0 || tokens[0].type !== \"code\") {\r\n                        console.error(\"Found magic link with nothing after the equals sign & no code block following: \" + split[0]);\r\n                    } else {\r\n                        value = (tokens.shift() as Tokens.Code).text;\r\n                    }\r\n                }\r\n                // This is a parameter\r\n                setKeyValue(magicLinks, key, value);\r\n            } else {\r\n                console.error(\"Unknown metadata key: \" + split[0]);\r\n            }\r\n            absorbWhitespace(tokens);\r\n        }\r\n\r\n        for (let i = 0; i < repeatTimes; i++) {\r\n            tests.push({\r\n                test: testString,\r\n                display: displayAs,\r\n                magicLinks\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction setKeyValue(kvList: KeyValue[], key: string, value: string) {\r\n    for (let kv of kvList) {\r\n        if (kv.key === key) {\r\n            kv.value = value;\r\n            return;\r\n        }\r\n    }\r\n    kvList.push(new KeyValue(key, value));\r\n}\r\n\r\n\r\nexport function removeNextHeading(tokens: Token[], expectedText: string) {\r\n    removeTillNextType(tokens, \"heading\");\r\n    if (tokens.length === 0) {\r\n        new Error(\"Problem Parse: Expected a heading with text: \" + expectedText);\r\n        return;\r\n    } else {\r\n        let heading = tokens.shift() as Tokens.Heading;\r\n        if (heading.text.trim().toLowerCase() === expectedText.trim().toLowerCase()) {\r\n            new Error(\"Problem Parse: Expected a heading with text: \" + expectedText + \" but got: \" + heading.text);\r\n        }\r\n    }\r\n}\r\n\r\nexport function removeTillNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n}\r\n\r\nexport function removeNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n    tokens.shift();\r\n}\r\n\r\nexport function absorbWhitespace(tokens: Token[]) {\r\n    while (tokens.length > 0 && tokens[0].type === \"space\") {\r\n        tokens.shift();\r\n    }\r\n}","import React from \"react\";\r\nimport {marked, saveUserData, UserData} from \"./Problem\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {expireToken, getToken, isLoggedIn, logIn} from \"../auth/AuthHelper\";\r\nimport {Button, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme} from \"../App\";\r\nimport {ProblemData, removeNextHeading} from \"./ProblemParse\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\n\r\nexport const LOADING_MESSAGE = \"Requesting help from the AI tutor...\";\r\n\r\nexport function HelpBoxAndButton(problemData: ProblemData,\r\n                                 setUserData: (userData: UserData) => void,\r\n                                 runTests: () => UserData,\r\n                                 response: string,\r\n                                 setResponse: (response: string) => void):\r\n    { helpButton: React.JSX.Element, helpBox: React.JSX.Element } {\r\n\r\n    function handleHelpRequest(event: React.MouseEvent<HTMLButtonElement>) {\r\n        event.currentTarget.setAttribute(\"disabled\", \"true\");\r\n\r\n        let userData = runTests();\r\n        if (!isLoggedIn()) {\r\n            setResponse(\"You must be logged in to use the AI tutor. Please log in and try again.\");\r\n            return;\r\n        }\r\n\r\n        let token = getToken();\r\n        let target = event.currentTarget;\r\n        setResponse(LOADING_MESSAGE);\r\n        fetch(\"https://codehelp.api.dacubeking.com/ai-tutor\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"content-type\": \"application/json\",\r\n                \"user-agent\": \"WeCode/1.0.0\",\r\n                accept: \"application/json\",\r\n                \"Authorization\": `token ${token}`\r\n            },\r\n            body: JSON.stringify({\r\n                problemData: problemData,\r\n                userData: userData,\r\n            })\r\n        })\r\n            .then(response => response.json())\r\n            .then((json: {\r\n                status: number,\r\n                prompt: string,\r\n                response: string,\r\n                expire_logins: boolean,\r\n                wait_time: number,\r\n            }) => {\r\n                if (json.expire_logins) {\r\n                    expireToken();\r\n                    logIn();\r\n                    setResponse(\"Your login has expired. Please try again after logging in.\");\r\n                    return;\r\n                }\r\n\r\n                if (json.status === 401) {\r\n                    setResponse(\"You are not authorized to use the AI tutor.\");\r\n                    return;\r\n                }\r\n\r\n\r\n                if (json.status === 429) {\r\n                    setResponse(\"You have made too many requests to the AI tutor. Please try again later.\");\r\n                    // Use the waitTime (seconds) to determine how long to wait before trying again\r\n                    new Promise((resolve) => setTimeout(resolve, json.wait_time * 1000)).then(() => {\r\n                        target.removeAttribute(\"disabled\");\r\n                    });\r\n                    return;\r\n                }\r\n\r\n                if (json.status !== 200) {\r\n                    setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                    target.removeAttribute(\"disabled\");\r\n                    return;\r\n                }\r\n\r\n\r\n                let tokens = marked.lexer(json.response);\r\n                // There are two sections: # Thinking out loud and # My Response\r\n                // We want to display the My Response section\r\n\r\n                // Remove Thinking out loud\r\n                removeNextHeading(tokens, \"Thinking out loud\");\r\n                // Remove the My Response heading\r\n                removeNextHeading(tokens, \"My Response\");\r\n\r\n                // Collect everything under the My Response heading\r\n                let response = \"\";\r\n                while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1 || (tokens[0] as Tokens.Heading).text.trim() !== \"Remembering\")) {\r\n                    response += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                removeNextHeading(tokens, \"Remembering\"); // Remove the Remembering heading\r\n                let rememberingResponse = \"\";\r\n                while (tokens.length > 0) {\r\n                    rememberingResponse += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                let newUserData = {\r\n                    ...userData,\r\n                    aiRememberResponse: userData.aiRememberResponse.concat(rememberingResponse),\r\n                }\r\n\r\n                setUserData(\r\n                    newUserData\r\n                );\r\n\r\n                saveUserData(problemData, newUserData);\r\n                setResponse(DOMPurify.sanitize(marked.parse(response) as string));\r\n                new Promise((resolve) => setTimeout(resolve, json.wait_time * 1000)).then(() => {\r\n                    target.removeAttribute(\"disabled\");\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                console.error(error);\r\n                setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                target.removeAttribute(\"disabled\");\r\n            });\r\n    }\r\n\r\n    let button = (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"secondary\"\r\n                    onClick={handleHelpRequest}\r\n                    className=\"helpButton\"\r\n            >\r\n                I'm stuck!\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n\r\n    let helpBox = (\r\n        <div className=\"AI-help-area border-2  p-2 mt-2 mb-4 mr-2 border-white-pink w-full min-h-20\">\r\n            <p className=\"Code-tutor-response\" dangerouslySetInnerHTML={{__html: response}}/>\r\n        </div>\r\n    );\r\n\r\n\r\n    return {\r\n        helpButton: button,\r\n        helpBox: helpBox\r\n    }\r\n}","import {UserData} from \"./Problem\";\r\nimport {ProblemData} from \"./ProblemParse\";\r\nimport {Log} from \"capture-console-logs/dist/logs\";\r\nimport * as util from \"util\";\r\nimport * as acorn from \"acorn\";\r\n\r\nconst functionHeaderOffset = 2;\r\n\r\nexport enum TestResult {\r\n    Passed = \"Passed\",\r\n    Failed = \"Failed\",\r\n    Exception = \"Exception\",\r\n    NotRun = \"Not run\"\r\n}\r\n\r\nexport class TestResults {\r\n    public testResults: TestResult[] = [];\r\n    public returnedResults: string[] = [];\r\n    public expectedResults: string[] = [];\r\n    public parseError: string = \"\";\r\n    public errorLine: number = -1;\r\n    public runtimeError: string = \"\";\r\n    public outputs: string[][] = [];\r\n    public ranSuccessfully: boolean = true; // Prevents the user from seeing an error message on first load\r\n}\r\n\r\nclass StringLineNum {\r\n    public str: string;\r\n    public lineNum: number;\r\n\r\n    constructor(str: string, lineNum: number) {\r\n        this.str = str;\r\n        this.lineNum = lineNum;\r\n    }\r\n}\r\n\r\nconst CaptureConsole = require(\"capture-console-logs\").default\r\n\r\n\r\n// Function to tokenize a JavaScript function signature\r\nfunction tokenizeFunctionSignature(signature: string): StringLineNum[] {\r\n    let tokens: StringLineNum[] = [];\r\n    let lineNum = 1;\r\n\r\n    const tokenChars = [' ', '(', ')', '{', '}', ':', ',', ';', '\\n'];\r\n\r\n\r\n    let bufferStartIndex = 0;\r\n    for (let i = 0; i < signature.length; i++) {\r\n        if (tokenChars.includes(signature[i])) {\r\n            if (bufferStartIndex !== i) {\r\n                tokens.push(new StringLineNum(signature.substring(bufferStartIndex, i), lineNum));\r\n            }\r\n            // We also need to add the token character as a separate token.\r\n            // Don't add a token for a space character.\r\n            // Don't add a token for a new line character\r\n            // (but if we haven't seen a semicolon, on a line with content, add a token).\r\n            if (signature[i] !== ' ' && signature[i] !== '\\n') {\r\n                tokens.push(new StringLineNum(signature[i], lineNum));\r\n            }\r\n\r\n            if (signature[i] === '\\n') {\r\n                lineNum++;\r\n            }\r\n\r\n            bufferStartIndex = i + 1;\r\n        }\r\n    }\r\n\r\n    // Filter out any empty tokens\r\n    return tokens.filter(token => token.str !== \"\");\r\n}\r\n\r\n/**\r\n * Reformat the stack trace to show the user's code line numbers\r\n * @param result The error object\r\n * @param userCodeLineNumbersBegin The line numbers of the user's code\r\n * @param userCodeLineNumbersEnd The line numbers of the user's code\r\n */\r\nfunction reformatStackTrace(result: Error, userCodeLineNumbersBegin: number[], userCodeLineNumbersEnd: number[], addedLines: number[]): number {\r\n    let stackTrace = result.stack;\r\n    if (stackTrace === undefined) {\r\n        stackTrace = \"\";\r\n    }\r\n    let stackTraceLines = stackTrace.split('\\n');\r\n    // discard after when the line begins with \"at testUserCode\"\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        if (thisLine.startsWith(\"at testUserCode\") || thisLine.startsWith(\"at Function\") || thisLine.startsWith(\"at eval\")) {\r\n            stackTraceLines = stackTraceLines.slice(0, j);\r\n            break;\r\n        }\r\n    }\r\n\r\n    const regex = /eval\\s+at\\s+\\w+\\s+\\(https?:\\/\\/[^)]+\\),\\s+<anonymous>:/g;\r\n\r\n    // remove the (eval at testUserCode (url) <anonymous:) part (keep the line number/col number)\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        stackTraceLines[j] = stackTraceLines[j].replace(regex, \"\");\r\n    }\r\n\r\n    let errorLine = -1\r\n    // Find the line number of the error & adjust line numbers to match the user's code\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        let matches = thisLine.match(/(\\d+):(\\d+)/);\r\n        if (matches !== null) {\r\n            let lineNumber = parseInt(matches[1]) - functionHeaderOffset; // Retrieve the line number\r\n\r\n            let userCodeLineNumberBegin = -1;\r\n            let userCodeLineNumberEnd = -1;\r\n\r\n            for (let i = 0; i < userCodeLineNumbersBegin.length; i++) {\r\n                if (lineNumber >= userCodeLineNumbersBegin[i] && lineNumber <= userCodeLineNumbersEnd[i]) {\r\n                    userCodeLineNumberBegin = userCodeLineNumbersBegin[i];\r\n                    userCodeLineNumberEnd = userCodeLineNumbersEnd[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (userCodeLineNumberBegin !== -1 && userCodeLineNumberEnd !== -1) {\r\n                let newLineNumber = lineNumber - userCodeLineNumberBegin + 1;\r\n\r\n                let lineNumberOffset = 0;\r\n                for (let i = 0; i < addedLines.length; i++) {\r\n                    if (newLineNumber > addedLines[i]) {\r\n                        lineNumberOffset++;\r\n                    }\r\n                }\r\n\r\n                newLineNumber -= lineNumberOffset;\r\n\r\n                let columnNumber = parseInt(matches[2]); // Retrieve the column number\r\n                let newLine = `${newLineNumber}:${columnNumber}`; // Construct the new line with adjusted line number\r\n                stackTraceLines[j] = thisLine.replace(matches[0], newLine); // Replace the entire matched portion with the new line\r\n                if (errorLine === -1) {\r\n                    errorLine = newLineNumber;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //result.stack += \"\\nNew Stack:\\n\" + stackTraceLines.join('\\n');\r\n    result.stack = stackTraceLines.join('\\n');\r\n    return errorLine;\r\n}\r\n\r\nfunction safeToString(expectedResult: any) {\r\n    if (expectedResult === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    if (expectedResult === null) {\r\n        return \"null\";\r\n    }\r\n    return expectedResult.toString();\r\n}\r\n\r\nexport function testUserCode(userData: UserData, problemData: ProblemData): TestResults {\r\n    let userCode = userData.currentCode;\r\n\r\n    let ast;\r\n    try {\r\n        ast = acorn.parse(userCode, {ecmaVersion: \"latest\", locations: true});\r\n    } catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n            let message = e.message;\r\n\r\n            // @ts-ignore\r\n            if (e.pos === userCode.length) {\r\n                message += \"\\nUnexpected end of input. Check that you have closed all brackets and parentheses.\";\r\n            }\r\n\r\n\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: message,\r\n                // @ts-ignore\r\n                errorLine: e.loc.line,\r\n                runtimeError: \"\",\r\n                outputs: [],\r\n                ranSuccessfully: false\r\n            };\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n\r\n    {\r\n        let missingFunctionError = {\r\n            returnableError: {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"You need to define a function with the following signature:\" + problemData.solutionCode.split('{')[0],\r\n                errorLine: 1,\r\n                runtimeError: \"\",\r\n                outputs: [],\r\n                ranSuccessfully: false\r\n            },\r\n            matchedTokens: 0,\r\n            // The levenshteinDistance between the missed token\r\n            levenshteinDistance: 100000\r\n        };\r\n\r\n        let foundFunction = false;\r\n\r\n        fnLoop: for (let func of ast.body) {\r\n            let functionSignature = userCode.substring(func.start, func.end).split('{')[0];\r\n            let tokens = tokenizeFunctionSignature(functionSignature);\r\n\r\n            let expectedFunctionSignature = problemData.solutionCode.split('{')[0];\r\n            let expectedTokens = tokenizeFunctionSignature(expectedFunctionSignature);\r\n\r\n            for (let i = 0; i < tokens.length; i++) {\r\n                if (tokens[i].str !== expectedTokens[i].str) {\r\n\r\n                    let parseError = \"Function signature does not match the expected signature. \";\r\n                    if (i === 0) {\r\n                        parseError += \"\\nThe function signature should begin with `\" + expectedTokens[i].str + \"` but you have \";\r\n                        if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                            parseError += \"nothing.\";\r\n                        } else {\r\n                            parseError += \"`\" + tokens[i].str + \"`.\";\r\n                        }\r\n                    } else {\r\n                        if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                            parseError += \"Expected: `\" + expectedTokens[i].str + \"` but got nothing.\";\r\n                        } else {\r\n                            parseError += \"Expected: `\" + expectedTokens[i].str + \"` after `\" + tokens.slice(0, i)\r\n                                .map(t => t.str).join(\" \") + \"` but got: `\" + tokens[i].str + \"`.\";\r\n                        }\r\n                    }\r\n\r\n                    let distance = levenshteinDistance(tokens[i].str, expectedTokens[i].str);\r\n\r\n                    // We also check the levenshtein distance\r\n                    // to see if the user has a typo and put the error on the closest match\r\n                    if (i > missingFunctionError.matchedTokens ||\r\n                        (distance < missingFunctionError.levenshteinDistance && i >= missingFunctionError.matchedTokens)) {\r\n                        missingFunctionError = {\r\n                            returnableError: {\r\n                                testResults: [],\r\n                                returnedResults: [],\r\n                                expectedResults: getExpectedResults(problemData),\r\n                                parseError,\r\n                                errorLine: tokens[i].lineNum,\r\n                                runtimeError: \"\",\r\n                                outputs: [],\r\n                                ranSuccessfully: false\r\n                            },\r\n                            matchedTokens: i,\r\n                            levenshteinDistance: distance\r\n                        }\r\n                    }\r\n                    continue fnLoop;\r\n                }\r\n            }\r\n\r\n            if (tokens.length !== expectedTokens.length) {\r\n                if (tokens.length > missingFunctionError.matchedTokens) {\r\n                    missingFunctionError = {\r\n                        returnableError: {\r\n                            testResults: [],\r\n                            returnedResults: [],\r\n                            expectedResults: getExpectedResults(problemData),\r\n                            parseError: \"Function signature does not match the expected signature. \" +\r\n                                \"Expected: \" + expectedFunctionSignature + \" but got: \" + functionSignature,\r\n                            errorLine: tokens[tokens.length - 1].lineNum,\r\n                            runtimeError: \"\",\r\n                            outputs: [],\r\n                            ranSuccessfully: false\r\n                        },\r\n                        matchedTokens: tokens.length,\r\n                        levenshteinDistance: 100000\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n            foundFunction = true;\r\n            break;\r\n        }\r\n\r\n        if (!foundFunction) {\r\n            return missingFunctionError.returnableError;\r\n        }\r\n    }\r\n\r\n    // We need to look for all the loops (for, while, do-while) and insert code to count the number of iterations.\r\n    // If the number of iterations exceeds 10000, we'll stop the code and return an error.\r\n    // This is to prevent infinite loops.\r\n\r\n    function findLoops(code: string) {\r\n        const loopRegex = /\\b(for|while|do\\s*while)\\s*\\((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)\\s*\\{/g;\r\n        const loops = [];\r\n        let match;\r\n\r\n        while ((match = loopRegex.exec(code)) !== null) {\r\n            loops.push({\r\n                type: match[1],\r\n                start: match.index,\r\n                end: findLoopEndIndex(code, match.index + match[0].length)\r\n            });\r\n        }\r\n\r\n        return loops;\r\n    }\r\n\r\n    function findLoopEndIndex(code: string, startIndex: number) {\r\n        let level = 1;\r\n        for (let i = startIndex; i < code.length; i++) {\r\n            if (code[i] === '{') {\r\n                level++;\r\n            } else if (code[i] === '}') {\r\n                level--;\r\n                if (level === 0) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1; // If loop end is not found\r\n    }\r\n\r\n\r\n    let loopCounterExtraLines: number[] = []\r\n\r\n    let loops = findLoops(userCode);\r\n    for (let i = 0; i < loops.length; i++) {\r\n        let loop = loops[i];\r\n        let loopHeaderStart = loop.start;\r\n        let loopHeaderEnd = userCode.indexOf('{', loopHeaderStart) + 1;\r\n\r\n        let loopHeader = userCode.substring(loopHeaderStart, loopHeaderEnd);\r\n        let preLoopCode = userCode.substring(0, loopHeaderStart);\r\n        let postLoopHeader = userCode.substring(loopHeaderEnd);\r\n\r\n        let lineOfCounter = preLoopCode.split('\\n').length;\r\n        let linePastLoopHeader = preLoopCode.split('\\n').length + loopHeader.split('\\n').length;\r\n\r\n        let loopCounterVar = \"loopCounter\" + crypto.randomUUID().replace(/-/g, '');\r\n        let userCodeAddPreLoop = `let ${loopCounterVar} = 0;\\n`;\r\n        let userCodeAddPostLoop = `if (${loopCounterVar}++ > 10000) { throw new Error(\"Infinite loop detected. Execution stopped.\"); }\\n`;\r\n        userCode = preLoopCode + userCodeAddPreLoop + loopHeader + userCodeAddPostLoop + postLoopHeader;\r\n\r\n        loopCounterExtraLines.push(lineOfCounter);\r\n        loopCounterExtraLines.push(linePastLoopHeader);\r\n\r\n        let addedChars = userCodeAddPreLoop.length + userCodeAddPostLoop.length;\r\n        //Adjust the line numbers of the loops\r\n        for (let j = i + 1; j < loops.length; j++) {\r\n            loops[j].start += addedChars;\r\n            loops[j].end += addedChars;\r\n        }\r\n    }\r\n\r\n    let solutionCode = problemData.solutionCode;\r\n    let resultsArrayName = \"results\" + crypto.randomUUID().replace(/-/g, '');\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n    let consoleLogArrayName = \"consoleLog\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${resultsArrayName} = [] || [];\r\nlet ${expectedResultsArrayName} = [] || [];\r\nlet ${consoleLogArrayName} = [] || [];\r\n    `;\r\n\r\n    let userCodeLineNumbersBegin: number[] = [];\r\n\r\n    let userCodeLineNumbersEnd: number[] = [];\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests)\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We need to run that twice:\r\n        //  - Once with the solution code\r\n        //  - Once with the user's code\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                {\r\n${solutionCode}\r\n                    try {\r\n                        expected = ${getResult}\r\n                    } catch (e) {\r\n                        expected = e;\r\n                    }\r\n                }\r\n                {\r\n                const cc = new CaptureConsole();\r\n                cc.start();\r\n                `;\r\n        userCodeLineNumbersBegin.push(codeToRun.split('\\n').length);\r\n        codeToRun += userCode;\r\n        userCodeLineNumbersEnd.push(codeToRun.split('\\n').length);\r\n\r\n        codeToRun += `\r\n                    try {\r\n                        result = ${getResult}\r\n                    } catch (e) {\r\n                        result = e;\r\n                    }\r\n                    cc.stop();\r\n                    ${consoleLogArrayName}.push(cc.getCaptures());\r\n                }\r\n            }\r\n            ${resultsArrayName}.push(result);\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return [${resultsArrayName}, ${expectedResultsArrayName}, ${consoleLogArrayName}];\r\n    `;\r\n\r\n    // eslint-disable-next-line\r\n    let resultsArray: any[] = [];\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n    let consoleLogArray: Log[][] = [];\r\n\r\n\r\n    let testResults = new TestResults();\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(\"CaptureConsole\", codeToRun);\r\n        let out = func(CaptureConsole);\r\n\r\n        resultsArray = out[0];\r\n        expectedResultsArray = out[1];\r\n        consoleLogArray = out[2];\r\n        testResults.ranSuccessfully = true;\r\n    } catch (e) {\r\n        testResults.ranSuccessfully = false;\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        testResults.expectedResults = getExpectedResults(problemData);\r\n        if (e instanceof Error) {\r\n            testResults.errorLine = reformatStackTrace(e, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n            console.log(e.stack);\r\n            testResults.runtimeError = e.stack as string;\r\n        } else {\r\n            testResults.runtimeError = e as string;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Check that we've actually run the test (i.e. we have a result)\r\n        if (i >= expectedResultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(\"Unknown\");\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.outputs.push([]);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        if (i >= resultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(expectedResultsArray[i].toString());\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.outputs.push([]);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        let result = resultsArray[i];\r\n        let expectedResult = expectedResultsArray[i];\r\n        let log: Log[];\r\n        if (i > problemData.tests.length) {\r\n            log = []; //Don't save console logs for hidden tests\r\n        } else {\r\n            log = consoleLogArray[i];\r\n\r\n        }\r\n\r\n        if (expectedResult instanceof Error) {\r\n            testResults.expectedResults.push(\"Error\");\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            console.error(\"A test case failed to run the solution: \" + expectedResult);\r\n            console.log(\"Test: \" + combinedTests[i]);\r\n            // TODO: Remove the bottom 2 lines\r\n            console.log(\"Solution: \" + problemData.solutionCode);\r\n            console.log(\"User code: \" + userCode);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.expectedResults.push(safeToString(expectedResult));\r\n        }\r\n\r\n        let outputArray: string[] = [];\r\n        for (let entry of log) {\r\n            let out = \"\";\r\n            if (entry.function !== \"log\") {\r\n                out = entry.function + \": \";\r\n            }\r\n\r\n            for (let arg of entry.args) {\r\n                if (arg instanceof Error) {\r\n                    reformatStackTrace(arg, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n                }\r\n            }\r\n\r\n            if (entry.args.length > 0) {\r\n                out += util.format(entry.args[0], ...entry.args.slice(1));\r\n            } else {\r\n                out += \"\";\r\n            }\r\n\r\n            outputArray.push(out);\r\n        }\r\n\r\n        testResults.outputs.push(outputArray);\r\n\r\n        if (result instanceof Error) {\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.Exception);\r\n            // End the stack trace at the user's code\r\n            testResults.errorLine = reformatStackTrace(result, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n\r\n            testResults.runtimeError = result.stack as string;\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.returnedResults.push(safeToString(result));\r\n        }\r\n\r\n        if (result !== expectedResult) {\r\n            testResults.testResults.push(TestResult.Failed);\r\n        } else {\r\n            testResults.testResults.push(TestResult.Passed);\r\n        }\r\n    }\r\n\r\n    return testResults;\r\n}\r\n\r\n\r\nexport function getExpectedResults(problemData: ProblemData): string[] {\r\n    // Parse the solution code and replace the function name with a random name\r\n    let solutionCode = problemData.solutionCode;\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${expectedResultsArrayName} = [] || [];\r\n    \r\n${solutionCode}\r\n    `;\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests);\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                try {\r\n                    expected = ${getResult}\r\n                } catch (e) {\r\n                    expected = e;\r\n                }\r\n            }\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return ${expectedResultsArrayName}\r\n    `;\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(codeToRun);\r\n        expectedResultsArray = func();\r\n    } catch (e: any) {\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        console.log(\"Solution: \" + problemData.solutionCode);\r\n        return [];\r\n    }\r\n\r\n    return expectedResultsArray.map(result => safeToString(result));\r\n}\r\n\r\nconst levenshteinDistance = (s: string, t: string) => {\r\n    if (!s.length) return t.length;\r\n    if (!t.length) return s.length;\r\n    const arr = [];\r\n    for (let i = 0; i <= t.length; i++) {\r\n        arr[i] = [i];\r\n        for (let j = 1; j <= s.length; j++) {\r\n            arr[i][j] =\r\n                i === 0\r\n                    ? j\r\n                    : Math.min(\r\n                        arr[i - 1][j] + 1,\r\n                        arr[i][j - 1] + 1,\r\n                        arr[i - 1][j - 1] + (s[j - 1] === t[i - 1] ? 0 : 1)\r\n                    );\r\n        }\r\n    }\r\n    return arr[t.length][s.length];\r\n};","import {Marked} from \"marked\";\r\nimport {markedHighlight} from \"marked-highlight\";\r\nimport hljs from \"highlight.js/lib/common\";\r\nimport React, {lazy, Suspense, useEffect, useState} from \"react\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {HelpBoxAndButton} from \"./Help\";\r\nimport {useParams} from \"react-router-dom\";\r\nimport 'katex/dist/katex.min.css';\r\nimport {getUserName} from \"../auth/AuthHelper\";\r\nimport {getExpectedResults, TestResult, TestResults, testUserCode} from \"./CodeRunner\";\r\nimport {Button, Popover, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme, mutedButtonTheme} from \"../App\";\r\nimport markedKatex from \"marked-katex-extension\";\r\nimport {parseProblem, ProblemData, TestCase} from \"./ProblemParse\";\r\n\r\nhljs.registerAliases([\"\"], {languageName: \"javascript\"})\r\n\r\nconst Editor = lazy(() => import(\"./Editor\"));\r\nexport const marked = new Marked(\r\n    markedHighlight({\r\n        langPrefix: 'hljs language-',\r\n        highlight(code, lang, info) {\r\n            const language = hljs.getLanguage(lang) ? lang : 'plaintext';\r\n            return hljs.highlight(code, {language}).value;\r\n        }\r\n    })\r\n);\r\n\r\nconst options = {\r\n    throwOnError: false,\r\n    displayMode: false,\r\n};\r\n\r\nmarked.use(markedKatex(options));\r\n\r\nexport function saveUserData(problemData: ProblemData, userData: UserData) {\r\n    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n        console.error(\"User data is being saved with no code\");\r\n    }\r\n\r\n    localStorage.setItem(getStorageKey(problemData.id, getUserName()), JSON.stringify(userData));\r\n}\r\n\r\nfunction getStorageKey(id: string, userName: string | undefined) {\r\n    return \"problem \" + id;\r\n}\r\n\r\nexport default function Problem() {\r\n    const [problemData, setProblemData] = useState(null as unknown as ProblemData);\r\n    const {\"*\": id} = useParams();\r\n    const [userData, setUserData] = useState(null as unknown as UserData);\r\n    const [helpResponse, setHelpResponse] = useState(\"When you press \\\"I'm stuck\\\", the AI tutor will respond here.\");\r\n    const [magicLinksHover, setMagicLinks] = useState({\r\n        anchorEl: null as (HTMLElement | null),\r\n        magicLink: \"\",\r\n    })\r\n\r\n    function onCodeSubmit() {\r\n        return onSubmission(problemData, userData, setUserData);\r\n    }\r\n\r\n    let normalizedId = id?.toLowerCase();\r\n    normalizedId?.trim()\r\n    if (normalizedId?.startsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(1)\r\n    }\r\n\r\n    if (normalizedId?.endsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(0, normalizedId.length - 1)\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (normalizedId !== undefined) {\r\n            fetch(process.env.PUBLIC_URL + \"/problems/\" + normalizedId + \".md\")\r\n                .then(async r => {\r\n                    let text = await r.text()\r\n                    if (!r.ok || !text.startsWith(\"#\")) {\r\n                        throw new Error(\"Failed to fetch problem data\");\r\n                    } else {\r\n                        return text;\r\n                    }\r\n                })\r\n                .then(async text => {\r\n                    // @ts-ignore - we've check that the id isn't undefined\r\n                    let problemData = parseProblem(text, normalizedId);\r\n                    let userData = getUserData(normalizedId, getUserName());\r\n\r\n                    // set the template data if the user has not saved any data\r\n                    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n                        console.log(\"First time loading problem, setting template data\");\r\n                        if (problemData.displayAbove !== \"\" && problemData.displayBelow !== \"\") {\r\n                            userData.currentCode = problemData.displayAbove + \"\\n\\t\\n\" + problemData.displayBelow;\r\n                        }\r\n                    }\r\n\r\n                    if (userData.testResults === undefined || userData.testResults === null || userData.testResults.expectedResults.length === 0) {\r\n                        console.log(\"First time loading problem, getting expected results\");\r\n                        userData.testResults = new TestResults()\r\n                        userData.testResults.expectedResults = getExpectedResults(problemData);\r\n\r\n                    }\r\n\r\n                    setProblemData(problemData);\r\n                    setUserData(userData);\r\n                })\r\n                .catch(e => {\r\n                    console.error(e);\r\n                    let problemData = new ProblemData();\r\n                    problemData.title = \"Failed to load problem \" + normalizedId;\r\n                    setProblemData(problemData);\r\n                });\r\n        }\r\n    }, [normalizedId]);\r\n\r\n\r\n    if (problemData === null || userData === null) {\r\n        if (problemData != null && problemData.title !== undefined && problemData.title.startsWith(\"Failed to load problem\") && normalizedId !== undefined) {\r\n            return <div>Failed to load problem {normalizedId}</div>;\r\n        }\r\n        if (normalizedId !== undefined) {\r\n            return <div>Loading...</div>;\r\n        } else {\r\n            return <div>A problem wasn't specified</div>;\r\n        }\r\n    }\r\n\r\n    let hljsLang = problemData.codeLang;\r\n    if (hljsLang === \"\") {\r\n        hljsLang = \"plaintext\";\r\n    }\r\n\r\n    let descParsed = DOMPurify.sanitize(marked.parse(problemData.preProblemDescription + \"\\n\\n\" + problemData.description) as string);\r\n\r\n    const handlePopoverOpen = (event: React.MouseEvent<HTMLElement>, magicLink: string) => {\r\n        setMagicLinks({\r\n            anchorEl: event.currentTarget as HTMLElement,\r\n            magicLink: magicLink\r\n        });\r\n    };\r\n\r\n    const handlePopoverClose = () => {\r\n        setMagicLinks({\r\n            anchorEl: null,\r\n            magicLink: magicLinksHover.magicLink\r\n        });\r\n    };\r\n\r\n    const open = Boolean(magicLinksHover.anchorEl);\r\n\r\n\r\n    let testsDisplay = [];\r\n\r\n    for (let i = 0; i < problemData.tests.length; i++) {\r\n        testsDisplay.push(getTestElement(problemData.tests, userData.testResults, i,\r\n            handlePopoverOpen, handlePopoverClose));\r\n    }\r\n\r\n    let testsDisplayJSX = <div>There are no visible test cases</div>;\r\n    if (testsDisplay.length > 0) {\r\n        testsDisplayJSX = <ul className=\"\">\r\n            {testsDisplay.map((test, i) => <li key={i}>{test}</li>)}\r\n        </ul>\r\n    }\r\n\r\n\r\n    let hiddenTestText: string;\r\n    if (userData.testResults.testResults.length === 0) {\r\n        hiddenTestText = \"Hidden tests will be run when you submit your code\";\r\n    } else {\r\n        let totalHiddenTests = problemData.hiddenTests.length;\r\n        let hiddenTestsPassed = 0;\r\n        for (let i = 0; i < problemData.hiddenTests.length; i++) {\r\n            if (userData.testResults.testResults[i + problemData.tests.length] === TestResult.Passed) {\r\n                hiddenTestsPassed++;\r\n            }\r\n        }\r\n        hiddenTestText = hiddenTestsPassed + \" / \" + totalHiddenTests + \" hidden tests passed\";\r\n    }\r\n\r\n    // Callback when the user updates their code\r\n    function updateUserCode(value: string) {\r\n        userData.currentCode = value;\r\n        saveUserData(problemData, userData);\r\n    }\r\n\r\n    let errorText: string = \"\"\r\n    let problemSolved = userData.testResults.testResults.every(result => result === TestResult.Passed) &&\r\n        userData.testResults.testResults.length === userData.testResults.expectedResults.length;\r\n\r\n    if (!userData.testResults.ranSuccessfully) {\r\n        if (userData.testResults.parseError !== \"\") {\r\n            errorText += \"We couldn't run your code due to a syntax error on line \" + userData.testResults.errorLine + \".\\n\";\r\n            errorText += indentText(userData.testResults.parseError, 1);\r\n        } else if (userData.testResults.runtimeError !== \"\") {\r\n            errorText += \"Something went wrong trying to run you code\"\r\n            if (userData.testResults.errorLine !== -1) {\r\n                errorText += \" on line \" + userData.testResults.errorLine + \".\\n\";\r\n            } else {\r\n                errorText += \".\\n\";\r\n            }\r\n            errorText += indentText(userData.testResults.runtimeError, 1);\r\n        } else {\r\n            errorText += \"No error message was provided.\"\r\n        }\r\n    }\r\n\r\n    errorText = errorText.replace(/\\n/g, \"<br>\");\r\n    errorText = DOMPurify.sanitize(errorText);\r\n\r\n    let {helpButton, helpBox} =\r\n        HelpBoxAndButton(problemData, setUserData, onCodeSubmit, helpResponse, setHelpResponse);\r\n\r\n    let nextProblem;\r\n    if (problemData.nextProblemId !== \"\" && problemData.nextProblemId.toLowerCase() !== \"nothing\") {\r\n        nextProblem = <ThemeProvider theme={mutedButtonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color={problemSolved ? \"secondary\" : \"primary\"}\r\n                    href={\"/problem/\" + problemData.nextProblemId}\r\n                    className={\"nextProblemButton\"}>\r\n                Next Problem\r\n            </Button>\r\n        </ThemeProvider>\r\n    } else {\r\n        nextProblem = <div/>\r\n    }\r\n\r\n\r\n    let highlightHover = hljs.highlight(magicLinksHover.magicLink, {language: hljsLang});\r\n    let hoverHtml = DOMPurify.sanitize(highlightHover.value.replace(/\\n/g, \"<br>\"));\r\n\r\n    return (\r\n        <div className=\"ml-5 flex-row\">\r\n            <div className=\"text-7xl font-bold pt-1 pb-5\">{problemData.title}</div>\r\n            <div className=\"w-1/2\" dangerouslySetInnerHTML={{__html: descParsed}}/>\r\n            <div className=\"flex flex-row justify-between h-auto pt-2\">\r\n                <div className=\"w-1/2 h-[calc(100vh*0.80)]\">\r\n                    <Suspense fallback={<div className={\"italic text-gray-300\"}>The Editor is loading...</div>}>\r\n                        <Editor\r\n                            lang={problemData.codeLang}\r\n                            onChange={(value) => updateUserCode(value)}\r\n                            defaultValue={userData.currentCode}\r\n                        />\r\n                    </Suspense>\r\n\r\n                    <div className=\"pt-2\">\r\n                        {nextProblem}\r\n                    </div>\r\n                </div>\r\n                <div className=\"w-1/2 pl-4 pr-4\">\r\n                    <div className=\"text-3xl font-bold w-1/3\"> Tests</div>\r\n                    {testsDisplayJSX}\r\n                    <p className=\"Problem-hidden-tests\">\r\n                        {hiddenTestText}\r\n                    </p>\r\n                    <SubmitButton onClick={onCodeSubmit}/> {helpButton}\r\n                    <div className=\"text-error-red\" dangerouslySetInnerHTML={{__html: errorText}}/>\r\n                    {helpBox}\r\n                </div>\r\n            </div>\r\n            <Popover\r\n                id=\"mouse-over-popover\"\r\n                sx={{\r\n                    pointerEvents: 'none',\r\n                }}\r\n                open={open}\r\n                anchorEl={magicLinksHover.anchorEl}\r\n                anchorOrigin={{\r\n                    vertical: 'bottom',\r\n                    horizontal: 'left',\r\n                }}\r\n                transformOrigin={{\r\n                    vertical: 'top',\r\n                    horizontal: 'left',\r\n                }}\r\n                onClose={handlePopoverClose}\r\n                disableRestoreFocus\r\n            >\r\n                <div className=\"p-2 bg-basically-black text-[#abb2bf]\"\r\n                     style={{\r\n                         fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\r\n                         whiteSpace: \"pre-wrap\",\r\n                     }}\r\n                     dangerouslySetInnerHTML={{__html: hoverHtml}\r\n                     }/>\r\n            </Popover>\r\n        </div>\r\n    );\r\n}\r\n\r\n/**\r\n * Returns a JSX element for a test case\r\n */\r\nfunction getTestElement(testCases: TestCase[], testResults: TestResults, index: number,\r\n                        handlePopoverOpen: (event: React.MouseEvent<HTMLElement>, magicLink: string) => void,\r\n                        handlePopoverClose: () => void) {\r\n    let result = testResults.testResults[index];\r\n    let resultText = result === undefined ? \"Not Run\" : result.toString();\r\n    if (result === TestResult.Failed) {\r\n        resultText += \" (Returned: \" + testResults.returnedResults[index] + \")\";\r\n    }\r\n\r\n    let bgColor = result === TestResult.Passed ? \"bg-test-passed\" : \"bg-test-failed\";\r\n\r\n    class MagicLink {\r\n        text: string;\r\n        link: string;\r\n\r\n        constructor(text: string, link: string) {\r\n            this.text = text;\r\n            this.link = link;\r\n        }\r\n    }\r\n\r\n    let testStringPart: (string | MagicLink)[] = [];\r\n\r\n    let testString = testCases[index].display;\r\n\r\n    for (const entries of testCases[index].magicLinks.values()) {\r\n        let key = entries.key;\r\n        let value = entries.value;\r\n\r\n        let index = testString.indexOf(key);\r\n\r\n        if (index === -1) {\r\n            console.error(\"Failed to find magic link in test string: \" + key);\r\n            continue;\r\n        }\r\n        if (index > 0) {\r\n            testStringPart.push(testString.substring(0, index));\r\n            testString = testString.substring(index);\r\n        }\r\n        testStringPart.push(new MagicLink(key, value));\r\n        testString = testString.substring(key.length);\r\n    }\r\n\r\n    testStringPart.push(testString);\r\n    let shouldDisplayConsole = testResults.outputs[index] !== undefined && testResults.outputs[index].length > 0;\r\n\r\n\r\n    let resultSpan;\r\n    if (shouldDisplayConsole) {\r\n        let consoleOutput = shouldDisplayConsole ? \"Console Output: \\n\" + testResults.outputs[index].join(\"\\n\") : \"\";\r\n\r\n        resultSpan =\r\n            <span className={\"underline decoration-gray-600 underline-offset-2\"}\r\n                  onMouseEnter={(e) => handlePopoverOpen(e, consoleOutput)}\r\n                  onMouseLeave={handlePopoverClose}>\r\n            {testResults.expectedResults[index]} : {resultText}\r\n        </span>\r\n    } else {\r\n        resultSpan = <span>{testResults.expectedResults[index]} : {resultText}</span>\r\n    }\r\n\r\n\r\n    let div = <div className={\"mb-2 text-black font-bold pl-1 \" + bgColor}>\r\n        {testStringPart.map((part, i) => {\r\n            if (part instanceof MagicLink) {\r\n                return <span key={i} className={\"text-purple-800 underline\"}\r\n                             onMouseEnter={(e) => handlePopoverOpen(e, part.text + \" = \" + part.link)}\r\n                             onMouseLeave={handlePopoverClose}>{part.text}</span>\r\n            } else {\r\n                return <span key={i}>{part}</span>\r\n            }\r\n        })}\r\n        <span>\r\n            {\" ➔ \"}\r\n        </span>\r\n        {resultSpan}\r\n    </div>\r\n\r\n\r\n    return (\r\n        div\r\n    );\r\n}\r\n\r\n/**\r\n * Returns the text indented by a number of tabs\r\n */\r\nfunction indentText(text: string, indent: number) {\r\n    let indentText = \"<span style='margin-left: \" + (indent * 2) + \"em'> </span>\";\r\n\r\n    return text.split(\"\\n\").map(line => indentText + line).join(\"\\n\");\r\n}\r\n\r\nexport class UserData {\r\n    history: string[] = [];\r\n    requestHelpHistory: string[] = [];\r\n    testResults: TestResults = new TestResults();\r\n    lastUpdated: Date = new Date();\r\n    currentCode: string = null as unknown as string;\r\n    aiRememberResponse: string[] = [];\r\n\r\n    constructor(history: string[] = [], requestHelpHistory: string[] = [], testResults: TestResults = new TestResults(), lastUpdated: Date = new Date(), currentCode: string = \"\", aiRememberResponse: string[] = []) {\r\n        this.history = history;\r\n        this.testResults = testResults;\r\n        this.requestHelpHistory = requestHelpHistory;\r\n        this.lastUpdated = lastUpdated;\r\n        this.currentCode = currentCode;\r\n        this.aiRememberResponse = aiRememberResponse;\r\n    }\r\n}\r\n\r\n/**\r\n * Loads the user data from local storage\r\n * @param id The id of the problem\r\n * @param userName The username of the user\r\n */\r\nfunction getUserData(id: string | undefined, userName: string | undefined) {\r\n    if (id === undefined) {\r\n        console.error(\"No problem id was specified, so no user data could be retrieved.\");\r\n        return new UserData();\r\n    }\r\n    let userData = localStorage.getItem(getStorageKey(id, userName));\r\n    if (userData === null) {\r\n        // try to get the data without the username\r\n        userData = localStorage.getItem(getStorageKey(id, undefined));\r\n        if (userData !== null) {\r\n            console.log(\"Got user data without username\");\r\n        }\r\n    }\r\n    if (userData === null) {\r\n        return new UserData();\r\n    }\r\n\r\n    return JSON.parse(userData) as UserData;\r\n}\r\n\r\nfunction SubmitButton({onClick}: { onClick: () => void }) {\r\n    return (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"primary\"\r\n                    onClick={onClick}\r\n                    className={\"submitButton\"}\r\n            >\r\n                Test Code\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n}\r\n\r\n\r\nfunction onSubmission(problemData: ProblemData, userData: UserData, setUserData: (data: UserData) => void) {\r\n    if (userData.history.length === 0) {\r\n        // First submission\r\n        userData.history.push(userData.currentCode);\r\n    } else {\r\n        let lastSubmission = userData.history[userData.history.length - 1];\r\n        if (lastSubmission !== userData.currentCode) {\r\n            userData.history.push(userData.currentCode);\r\n        }\r\n    }\r\n\r\n    userData.lastUpdated = new Date();\r\n\r\n    let testResults = testUserCode(userData, problemData);\r\n\r\n    let newUserData = new UserData(\r\n        userData.history,\r\n        userData.requestHelpHistory,\r\n        testResults,\r\n        new Date(),\r\n        userData.currentCode,\r\n        userData.aiRememberResponse\r\n    )\r\n    setUserData(newUserData);\r\n    saveUserData(problemData, newUserData);\r\n    return newUserData;\r\n}"],"names":["ProblemData","constructor","id","title","preProblemDescription","description","tests","hiddenTests","displayAbove","displayBelow","solution","solutionCode","codeLang","nextProblemId","KeyValue","key","value","this","extractTestCases","tokens","length","absorbWhitespace","type","testString","shift","text","trim","split","flatMap","s","functionCall","indexBeginParen","indexOf","indexEndParen","i","console","error","params","substring","map","repeatTimes","displayAs","endsWith","magicLinks","param","match","RegExp","concat","undefined","index","bracketCount","curlyCount","doubleQuoteCount","singleQuoteCount","backtickCount","c","setKeyValue","metaData","toLowerCase","num","parseInt","isNaN","includes","push","test","display","kvList","kv","removeNextHeading","expectedText","removeTillNextType","heading","Error","LOADING_MESSAGE","functionHeaderOffset","TestResult","TestResults","testResults","returnedResults","expectedResults","parseError","errorLine","runtimeError","outputs","ranSuccessfully","StringLineNum","str","lineNum","CaptureConsole","require","tokenizeFunctionSignature","signature","tokenChars","bufferStartIndex","filter","token","reformatStackTrace","result","userCodeLineNumbersBegin","userCodeLineNumbersEnd","addedLines","stackTrace","stack","stackTraceLines","j","thisLine","startsWith","slice","regex","replace","matches","lineNumber","userCodeLineNumberBegin","userCodeLineNumberEnd","newLineNumber","lineNumberOffset","columnNumber","newLine","join","safeToString","expectedResult","toString","getExpectedResults","problemData","expectedResultsArrayName","crypto","randomUUID","codeToRun","combinedTests","testSplitByLines","setupCode","getResult","expectedResultsArray","Function","func","e","log","levenshteinDistance","t","arr","Math","min","hljs","registerAliases","languageName","Editor","lazy","marked","Marked","markedHighlight","langPrefix","highlight","code","lang","info","language","getLanguage","saveUserData","userData","currentCode","localStorage","setItem","getStorageKey","getUserName","JSON","stringify","userName","Problem","_normalizedId","_normalizedId2","_normalizedId3","setProblemData","useState","useParams","setUserData","helpResponse","setHelpResponse","magicLinksHover","setMagicLinks","anchorEl","magicLink","onCodeSubmit","history","lastUpdated","Date","ast","userCode","acorn","ecmaVersion","locations","SyntaxError","message","pos","loc","line","missingFunctionError","returnableError","matchedTokens","foundFunction","fnLoop","body","functionSignature","start","end","expectedFunctionSignature","expectedTokens","distance","findLoopEndIndex","startIndex","level","loopCounterExtraLines","loops","loopRegex","exec","findLoops","loopHeaderStart","loopHeaderEnd","loopHeader","preLoopCode","postLoopHeader","lineOfCounter","linePastLoopHeader","loopCounterVar","userCodeAddPreLoop","userCodeAddPostLoop","addedChars","resultsArrayName","consoleLogArrayName","resultsArray","consoleLogArray","out","NotRun","outputArray","entry","function","arg","args","util","format","Exception","Failed","Passed","testUserCode","newUserData","UserData","requestHelpHistory","aiRememberResponse","onSubmission","normalizedId","useEffect","fetch","then","async","r","ok","lexer","depth","raw","problem","splitProblem","parseProblem","getItem","parse","getUserData","catch","_jsxs","children","_jsx","hljsLang","descParsed","DOMPurify","handlePopoverOpen","event","currentTarget","handlePopoverClose","open","Boolean","testsDisplay","getTestElement","hiddenTestText","testsDisplayJSX","className","totalHiddenTests","hiddenTestsPassed","errorText","problemSolved","every","indentText","nextProblem","helpButton","helpBox","runTests","response","setResponse","button","ThemeProvider","theme","buttonTheme","Button","variant","color","onClick","setAttribute","isLoggedIn","getToken","target","method","headers","accept","json","expire_logins","expireToken","logIn","status","Promise","resolve","setTimeout","wait_time","removeAttribute","rememberingResponse","dangerouslySetInnerHTML","__html","HelpBoxAndButton","mutedButtonTheme","href","highlightHover","hoverHtml","Suspense","fallback","onChange","updateUserCode","defaultValue","SubmitButton","Popover","sx","pointerEvents","anchorOrigin","vertical","horizontal","transformOrigin","onClose","disableRestoreFocus","style","fontFamily","whiteSpace","testCases","resultText","bgColor","MagicLink","link","testStringPart","entries","values","resultSpan","shouldDisplayConsole","consoleOutput","onMouseEnter","onMouseLeave","part","indent","use","markedKatex","throwOnError","displayMode","arguments","_ref"],"sourceRoot":""}