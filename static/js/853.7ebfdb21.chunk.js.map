{"version":3,"file":"static/js/853.7ebfdb21.chunk.js","mappings":"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","sources":["problem/ProblemParse.ts","problem/Help.tsx","problem/CodeRunner.ts","problem/Problem.tsx"],"sourcesContent":["import {marked} from \"./Problem\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\nexport class ProblemData {\r\n    id: string = \"\";\r\n    title: string = 'Loading...';\r\n    preProblemDescription: string = \"\";\r\n    description: string = \"\";\r\n    tests: TestCase[] = [];\r\n    hiddenTests: TestCase[] = [];\r\n    displayAbove: string = \"\";\r\n    displayBelow: string = \"\";\r\n    solution: string = \"\";\r\n    solutionCode: string = \"\";\r\n    codeLang: string = \"\";\r\n    nextProblemId: string = \"\";\r\n}\r\n\r\nexport class TestCase {\r\n    test: string;\r\n    display: string;\r\n    magicLinks: KeyValue[];\r\n\r\n    constructor(test: string, display: string, magicLinks: KeyValue[]) {\r\n        this.test = test;\r\n        this.display = display;\r\n        this.magicLinks = magicLinks;\r\n    }\r\n}\r\n\r\nexport class KeyValue {\r\n    key: string;\r\n    value: string;\r\n\r\n    constructor(key: string, value: string) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nexport function parseProblem(text: string, id: string): ProblemData {\r\n    let tokens = marked.lexer(text);\r\n    let title = (tokens.shift() as Tokens.Heading).text;\r\n\r\n    let preProblemDescription = \"\";\r\n    removeTillNextType(tokens, \"heading\"); // Collect everything under the description heading\r\n    if ((tokens[0] as Tokens.Heading).text === \"Context\") {\r\n        tokens.shift();\r\n        while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n            preProblemDescription += ((tokens.shift() as Token).raw);\r\n        }\r\n    }\r\n\r\n    // Collect everything under the description heading\r\n    removeNextHeading(tokens, \"description\"); // Remove the description heading\r\n\r\n    let description = \"\";\r\n    while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n        description += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Problem\"); // Remove the problem heading\r\n    if (tokens[0].type !== \"code\") {\r\n        console.error(\"Problem Parse: No code block found after problem heading. If no template code is needed, please use a code block with no content (with the correct language).\");\r\n    }\r\n    let problem = tokens.shift() as Tokens.Code;\r\n    if (!problem.lang) {\r\n        console.error(\"Problem Parse: No code language specified for problem \" + id);\r\n    }\r\n    let codeLang = problem.lang ? problem.lang : \"javascript\";\r\n\r\n    let splitProblem = problem.text.split(\"// Your code here\");\r\n\r\n    let displayAbove;\r\n    let displayBelow;\r\n\r\n    if (splitProblem.length === 0 || splitProblem[0].trim() === \"\") {\r\n        console.log(\"Problem Parse: Code block has no content\");\r\n        displayAbove = \"\";\r\n        displayBelow = \"\";\r\n    } else {\r\n        displayAbove = splitProblem[0].trim();\r\n        if (splitProblem.length === 1) {\r\n            displayBelow = \"\";\r\n            console.error(\"Problem Parse: No secondary display content found in problem \" + id +\r\n                \". It is unlikely that this is intentional. Ensure that you have a comment with the text '// Your code here' in the problem description.\");\r\n        } else {\r\n            displayBelow = splitProblem[1].trim();\r\n        }\r\n    }\r\n\r\n\r\n    removeNextHeading(tokens, \"Solution\"); // Remove the solution heading\r\n    absorbWhitespace(tokens);\r\n    let solution = \"\";\r\n    let solutionCode = \"\";\r\n    while (tokens.length > 0 && !(tokens[0].type === \"heading\" && (tokens[0] as Tokens.Heading).depth <= 1)) {\r\n        if (tokens[0].type === \"code\" && solutionCode === \"\") {\r\n            // Get the first code block as the solution code\r\n            solutionCode += (tokens[0] as Tokens.Code).text;\r\n        }\r\n        solution += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Test Cases\"); // Remove the tests heading\r\n    let tests: TestCase[] = [];\r\n    extractTestCases(tokens, tests);\r\n\r\n    removeNextHeading(tokens, \"Hidden Test Cases\"); // Remove the hidden tests heading\r\n    let hiddenTests: TestCase[] = [];\r\n    extractTestCases(tokens, hiddenTests);\r\n\r\n    removeNextHeading(tokens, \"Next\");\r\n    let nextProblemId;\r\n    if (tokens.length === 0 || tokens[0].type !== \"paragraph\") {\r\n        nextProblemId = \"nothing\";\r\n    } else {\r\n        nextProblemId = (tokens.shift() as Tokens.Paragraph).text;\r\n        nextProblemId = nextProblemId.trim();\r\n        if (nextProblemId.startsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(1);\r\n        }\r\n        if (nextProblemId.endsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(0, nextProblemId.length - 1);\r\n        }\r\n        if (nextProblemId === \"\") {\r\n            nextProblemId = \"nothing\";\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        id,\r\n        title,\r\n        preProblemDescription,\r\n        description,\r\n        tests,\r\n        hiddenTests,\r\n        displayAbove,\r\n        displayBelow,\r\n        solution,\r\n        solutionCode,\r\n        codeLang,\r\n        nextProblemId\r\n    };\r\n}\r\n\r\nfunction extractTestCases(tokens: Token[], tests: TestCase[]) {\r\n    // Tests are formatted as a list of functions in a code block with the expected result below it\r\n    while (tokens.length > 0) {\r\n        absorbWhitespace(tokens);\r\n        if (tokens.length === 0 || tokens[0].type !== \"code\") break;\r\n        let test = tokens.shift() as Tokens.Code;\r\n\r\n        let testString = test.text.trim();\r\n        let split = testString.split(\"\\n\").flatMap((s) => s.trim());\r\n        let functionCall = split[split.length - 1];\r\n        let indexBeginParen = functionCall.indexOf(\"(\");\r\n        let indexEndParen = -1;\r\n        for (let i = functionCall.length - 1; i >= 0; i--) {\r\n            if (functionCall[i] === \")\") {\r\n                indexEndParen = i;\r\n                break;\r\n            }\r\n        }\r\n        if (indexBeginParen === -1 || indexEndParen === -1) {\r\n            console.error(\"Failed to parse function call (Magic Links will not work!): \" + functionCall);\r\n            continue;\r\n        }\r\n        let params = functionCall.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n        absorbWhitespace(tokens);\r\n        let repeatTimes = 1;\r\n        let displayAs = functionCall;\r\n        // Remove the last ; if it exists\r\n        if (displayAs.endsWith(\";\")) {\r\n            displayAs = displayAs.substring(0, displayAs.length - 1);\r\n        }\r\n\r\n        let magicLinks: KeyValue[] = [];\r\n\r\n        for (let param of params) {\r\n            // See if we can find where the parameter is defined in the code block\r\n            // We want to match let param = value;\r\n            let match = testString.match(new RegExp(`let\\\\s+${param}\\\\s*=\\\\s*`));\r\n            if (match !== null && match.index !== undefined) {\r\n                let value = testString.substring(match.index + match[0].length).trim();\r\n                let bracketCount = 0;\r\n                let curlyCount = 0;\r\n                let doubleQuoteCount = 0;\r\n                let singleQuoteCount = 0;\r\n                let backtickCount = 0;\r\n                for (let i = 0; i < value.length; i++) {\r\n                    let c = value[i];\r\n                    if (c === \"(\") {\r\n                        bracketCount++;\r\n                    } else if (c === \")\") {\r\n                        bracketCount--;\r\n                    } else if (c === \"{\") {\r\n                        curlyCount++;\r\n                    } else if (c === \"}\") {\r\n                        curlyCount--;\r\n                    } else if (c === \"\\\"\") {\r\n                        doubleQuoteCount++;\r\n                    } else if (c === \"'\") {\r\n                        singleQuoteCount++;\r\n                    } else if (c === \"`\") {\r\n                        backtickCount++;\r\n                    }\r\n                    if (bracketCount === 0 && curlyCount === 0 && doubleQuoteCount % 2 === 0 && singleQuoteCount % 2 === 0 && backtickCount % 2 === 0 && c === \";\" && i !== value.length - 1) {\r\n                        value = value.substring(0, i);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                setKeyValue(magicLinks, param, value);\r\n            }\r\n        }\r\n\r\n        // @ts-ignore - ts seems to not believe that type could be paragraph\r\n        while (tokens.length > 0 && tokens[0].type === \"paragraph\") {\r\n            let metaData = (tokens.shift() as Tokens.Paragraph).text.trim();\r\n\r\n            let split = metaData.split(\"=\").map(s => s.trim());\r\n            if (split.length !== 2) {\r\n                console.error(\"Failed to parse metadata: \" + metaData);\r\n                continue;\r\n            }\r\n            let key = split[0].toLowerCase();\r\n            let value = split[1];\r\n\r\n            if (key === \"repeat\") {\r\n                let num = parseInt(value);\r\n                if (isNaN(num)) {\r\n                    console.error(\"Failed to parse repeat value: \" + value);\r\n                } else {\r\n                    repeatTimes = num;\r\n                }\r\n            } else if (key === \"displayas\") {\r\n                displayAs = value;\r\n\r\n                let indexBeginParen = functionCall.indexOf(\"(\");\r\n                let indexEndParen = -1;\r\n                for (let i = displayAs.length - 1; i >= 0; i--) {\r\n                    if (displayAs[i] === \")\") {\r\n                        indexEndParen = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (indexBeginParen === -1 || indexEndParen === -1) {\r\n                    console.error(\"Failed to parse function for displayAs meta call (Magic Links will not work!): \" + displayAs);\r\n                    continue;\r\n                }\r\n                params = displayAs.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n            } else if (params.includes(split[0])) { // We don't want to remove the casing\r\n                let key = split[0];\r\n                let value = split[1];\r\n                if (split[1].length === 0) {\r\n                    // We should look for a code block\r\n                    absorbWhitespace(tokens);\r\n                    if (tokens.length === 0 || tokens[0].type !== \"code\") {\r\n                        console.error(\"Found magic link with nothing after the equals sign & no code block following: \" + split[0]);\r\n                    } else {\r\n                        value = (tokens.shift() as Tokens.Code).text;\r\n                    }\r\n                }\r\n                // This is a parameter\r\n                setKeyValue(magicLinks, key, value);\r\n            } else {\r\n                console.error(\"Unknown metadata key: \" + split[0]);\r\n            }\r\n            absorbWhitespace(tokens);\r\n        }\r\n\r\n        for (let i = 0; i < repeatTimes; i++) {\r\n            tests.push({\r\n                test: testString,\r\n                display: displayAs,\r\n                magicLinks\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction setKeyValue(kvList: KeyValue[], key: string, value: string) {\r\n    for (let kv of kvList) {\r\n        if (kv.key === key) {\r\n            kv.value = value;\r\n            return;\r\n        }\r\n    }\r\n    kvList.push(new KeyValue(key, value));\r\n}\r\n\r\n\r\nexport function removeNextHeading(tokens: Token[], expectedText: string) {\r\n    removeTillNextType(tokens, \"heading\");\r\n    if (tokens.length === 0) {\r\n        new Error(\"Problem Parse: Expected a heading with text: \" + expectedText);\r\n        return;\r\n    } else {\r\n        let heading = tokens.shift() as Tokens.Heading;\r\n        if (heading.text.trim().toLowerCase() === expectedText.trim().toLowerCase()) {\r\n            new Error(\"Problem Parse: Expected a heading with text: \" + expectedText + \" but got: \" + heading.text);\r\n        }\r\n    }\r\n}\r\n\r\nexport function removeTillNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n}\r\n\r\nexport function removeNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n    tokens.shift();\r\n}\r\n\r\nexport function absorbWhitespace(tokens: Token[]) {\r\n    while (tokens.length > 0 && tokens[0].type === \"space\") {\r\n        tokens.shift();\r\n    }\r\n}","import React from \"react\";\r\nimport {marked, saveUserData, UserData} from \"./Problem\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {expireToken, getToken, isLoggedIn, logIn} from \"../auth/AuthHelper\";\r\nimport {Button, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme} from \"../App\";\r\nimport {ProblemData, removeNextHeading} from \"./ProblemParse\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\n\r\nexport const LOADING_MESSAGE = \"Requesting help from the AI tutor...\";\r\n\r\nexport function HelpBoxAndButton(problemData: ProblemData,\r\n                                 setUserData: (userData: UserData) => void,\r\n                                 runTests: () => UserData,\r\n                                 response: string,\r\n                                 setResponse: (response: string) => void):\r\n    { helpButton: React.JSX.Element, helpBox: React.JSX.Element } {\r\n\r\n    function handleHelpRequest(event: React.MouseEvent<HTMLButtonElement>) {\r\n        event.currentTarget.setAttribute(\"disabled\", \"true\");\r\n\r\n        let userData = runTests();\r\n        if (!isLoggedIn()) {\r\n            setResponse(\"You must be logged in to use the AI tutor. Please log in and try again.\");\r\n            return;\r\n        }\r\n\r\n        let token = getToken();\r\n        let target = event.currentTarget;\r\n        setResponse(LOADING_MESSAGE);\r\n        fetch(\"https://codehelp.api.dacubeking.com/ai-tutor\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"content-type\": \"application/json\",\r\n                \"user-agent\": \"WeCode/1.0.0\",\r\n                accept: \"application/json\",\r\n                \"Authorization\": `token ${token}`\r\n            },\r\n            body: JSON.stringify({\r\n                problemData: problemData,\r\n                userData: userData,\r\n            })\r\n        })\r\n            .then(response => response.json())\r\n            .then((json: {\r\n                status: number,\r\n                prompt: string,\r\n                response: string,\r\n                expire_logins: boolean,\r\n            }) => {\r\n                if (json.expire_logins) {\r\n                    expireToken();\r\n                    logIn();\r\n                    setResponse(\"Your login has expired. Please try again after logging in.\");\r\n                    return;\r\n                }\r\n\r\n                if (json.status === 401) {\r\n                    setResponse(\"You are not authorized to use the AI tutor.\");\r\n                    return;\r\n                }\r\n\r\n                if (json.status !== 200) {\r\n                    setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                    return;\r\n                }\r\n\r\n                let tokens = marked.lexer(json.response);\r\n                // There are two sections: # Thinking out loud and # My Response\r\n                // We want to display the My Response section\r\n\r\n                // Remove Thinking out loud\r\n                removeNextHeading(tokens, \"Thinking out loud\");\r\n                // Remove the My Response heading\r\n                removeNextHeading(tokens, \"My Response\");\r\n\r\n                // Collect everything under the My Response heading\r\n                let response = \"\";\r\n                while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1 || (tokens[0] as Tokens.Heading).text.trim() !== \"Remembering\")) {\r\n                    response += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                removeNextHeading(tokens, \"Remembering\"); // Remove the Remembering heading\r\n                let rememberingResponse = \"\";\r\n                while (tokens.length > 0) {\r\n                    rememberingResponse += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                let newUserData = {\r\n                    ...userData,\r\n                    aiRememberResponse: userData.aiRememberResponse.concat(rememberingResponse),\r\n                }\r\n\r\n                setUserData(\r\n                    newUserData\r\n                );\r\n\r\n                saveUserData(problemData, newUserData);\r\n                setResponse(DOMPurify.sanitize(marked.parse(response) as string));\r\n                target.removeAttribute(\"disabled\");\r\n            })\r\n            .catch((error) => {\r\n                console.error(error);\r\n                setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                target.removeAttribute(\"disabled\");\r\n            });\r\n    }\r\n\r\n    let button = (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"secondary\"\r\n                    onClick={handleHelpRequest}\r\n                    className=\"helpButton\"\r\n            >\r\n                I'm stuck!\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n\r\n    let helpBox = (\r\n        <div className=\"AI-help-area border-2  p-2 mt-2 mb-4 mr-2 border-white-pink w-full min-h-20\">\r\n            <p className=\"Code-tutor-response\" dangerouslySetInnerHTML={{__html: response}}/>\r\n        </div>\r\n    );\r\n\r\n\r\n    return {\r\n        helpButton: button,\r\n        helpBox: helpBox\r\n    }\r\n}","import {UserData} from \"./Problem\";\r\nimport {ProblemData} from \"./ProblemParse\";\r\n\r\nconst functionHeaderOffset = 2;\r\n\r\nexport enum TestResult {\r\n    Passed = \"Passed\",\r\n    Failed = \"Failed\",\r\n    Exception = \"Exception\",\r\n    NotRun = \"Not run\"\r\n}\r\n\r\nexport class TestResults {\r\n    public testResults: TestResult[] = [];\r\n    public returnedResults: string[] = [];\r\n    public expectedResults: string[] = [];\r\n    public parseError: string = \"\";\r\n    public errorLine: number = -1;\r\n    public runtimeError: string = \"\";\r\n    public output: string = \"\";\r\n    public ranSuccessfully: boolean = true; // Prevents the user from seeing an error message on first load\r\n}\r\n\r\nclass StringLineNum {\r\n    public str: string;\r\n    public lineNum: number;\r\n\r\n    constructor(str: string, lineNum: number) {\r\n        this.str = str;\r\n        this.lineNum = lineNum;\r\n    }\r\n}\r\n\r\n// Function to tokenize a JavaScript function signature\r\nfunction tokenizeFunctionSignature(signature: string): StringLineNum[] {\r\n    let tokens: StringLineNum[] = [];\r\n    let lineNum = 1;\r\n\r\n    const tokenChars = [' ', '(', ')', '{', '}', ':', ',', ';', '\\n'];\r\n\r\n\r\n    let bufferStartIndex = 0;\r\n    for (let i = 0; i < signature.length; i++) {\r\n        if (tokenChars.includes(signature[i])) {\r\n            if (bufferStartIndex !== i) {\r\n                tokens.push(new StringLineNum(signature.substring(bufferStartIndex, i), lineNum));\r\n            }\r\n            // We also need to add the token character as a separate token.\r\n            // Don't add a token for a space character.\r\n            // Don't add a token for a new line character\r\n            // (but if we haven't seen a semicolon, on a line with content, add a token).\r\n            if (signature[i] !== ' ' && signature[i] !== '\\n') {\r\n                tokens.push(new StringLineNum(signature[i], lineNum));\r\n            }\r\n\r\n            if (signature[i] === '\\n') {\r\n                lineNum++;\r\n            }\r\n\r\n            bufferStartIndex = i + 1;\r\n        }\r\n    }\r\n\r\n    // Filter out any empty tokens\r\n    return tokens.filter(token => token.str !== \"\");\r\n}\r\n\r\n/**\r\n * Reformat the stack trace to show the user's code line numbers\r\n * @param result The error object\r\n * @param userCodeLineNumbersBegin The line numbers of the user's code\r\n * @param userCodeLineNumbersEnd The line numbers of the user's code\r\n */\r\nfunction reformatStackTrace(result: Error, userCodeLineNumbersBegin: number[], userCodeLineNumbersEnd: number[], addedLines: number[]): number {\r\n    let stackTrace = result.stack;\r\n    if (stackTrace === undefined) {\r\n        stackTrace = \"\";\r\n    }\r\n    let stackTraceLines = stackTrace.split('\\n');\r\n    // discard after when the line begins with \"at testUserCode\"\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        if (thisLine.startsWith(\"at testUserCode\") || thisLine.startsWith(\"at Function\") || thisLine.startsWith(\"at eval\")) {\r\n            stackTraceLines = stackTraceLines.slice(0, j);\r\n            break;\r\n        }\r\n    }\r\n\r\n    const regex = /eval\\s+at\\s+\\w+\\s+\\(https?:\\/\\/[^)]+\\),\\s+<anonymous>:/g;\r\n\r\n    // remove the (eval at testUserCode (url) <anonymous:) part (keep the line number/col number)\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        stackTraceLines[j] = stackTraceLines[j].replace(regex, \"\");\r\n    }\r\n\r\n    let errorLine = -1\r\n    // Find the line number of the error & adjust line numbers to match the user's code\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        let matches = thisLine.match(/(\\d+):(\\d+)/);\r\n        if (matches !== null) {\r\n            let lineNumber = parseInt(matches[1]) - functionHeaderOffset; // Retrieve the line number\r\n\r\n            let userCodeLineNumberBegin = -1;\r\n            let userCodeLineNumberEnd = -1;\r\n\r\n            for (let i = 0; i < userCodeLineNumbersBegin.length; i++) {\r\n                if (lineNumber >= userCodeLineNumbersBegin[i] && lineNumber <= userCodeLineNumbersEnd[i]) {\r\n                    userCodeLineNumberBegin = userCodeLineNumbersBegin[i];\r\n                    userCodeLineNumberEnd = userCodeLineNumbersEnd[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (userCodeLineNumberBegin !== -1 && userCodeLineNumberEnd !== -1) {\r\n                let newLineNumber = lineNumber - userCodeLineNumberBegin + 1;\r\n\r\n                let lineNumberOffset = 0;\r\n                for (let i = 0; i < addedLines.length; i++) {\r\n                    if (newLineNumber > addedLines[i]) {\r\n                        lineNumberOffset++;\r\n                    }\r\n                }\r\n\r\n                newLineNumber -= lineNumberOffset;\r\n\r\n                let columnNumber = parseInt(matches[2]); // Retrieve the column number\r\n                let newLine = `${newLineNumber}:${columnNumber}`; // Construct the new line with adjusted line number\r\n                stackTraceLines[j] = thisLine.replace(matches[0], newLine); // Replace the entire matched portion with the new line\r\n                if (errorLine === -1) {\r\n                    errorLine = newLineNumber;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //result.stack += \"\\nNew Stack:\\n\" + stackTraceLines.join('\\n');\r\n    result.stack = stackTraceLines.join('\\n');\r\n    return errorLine;\r\n}\r\n\r\nfunction safeToString(expectedResult: any) {\r\n    if (expectedResult === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    if (expectedResult === null) {\r\n        return \"null\";\r\n    }\r\n    return expectedResult.toString();\r\n}\r\n\r\nexport function testUserCode(userData: UserData, problemData: ProblemData): TestResults {\r\n    let userCode = userData.currentCode;\r\n\r\n    // Check that we have balanced brackets\r\n    {\r\n        let brackets = 0;\r\n        let lineNum = 1;\r\n        let foundFirstBracket = false;\r\n        let whitespaceRegex = /^\\s*$/;\r\n        let characterAfterLastBracket = {value: false, lineNum: -1};\r\n        for (let i = 0; i < userCode.length; i++) {\r\n            if (brackets === 0 && foundFirstBracket && !userCode[i].match(whitespaceRegex) && !characterAfterLastBracket.value) {\r\n                characterAfterLastBracket = {value: true, lineNum: lineNum};\r\n            }\r\n\r\n            if (userCode[i] === '{') {\r\n                if (foundFirstBracket && brackets === 0) {\r\n                    return {\r\n                        testResults: [],\r\n                        expectedResults: getExpectedResults(problemData),\r\n                        returnedResults: [],\r\n                        parseError: \"You began a new function after closing your first one. You cannot do that. If you want to define a new function, do it inside the first function.\",\r\n                        errorLine: lineNum,\r\n                        runtimeError: \"\",\r\n                        output: \"\",\r\n                        ranSuccessfully: false\r\n                    };\r\n                }\r\n\r\n                brackets++;\r\n                foundFirstBracket = true;\r\n            } else if (userCode[i] === '}') {\r\n                brackets--;\r\n            }\r\n\r\n            if (userCode[i] === '\\n') {\r\n                lineNum++;\r\n            }\r\n\r\n            if (brackets < 0) {\r\n                return {\r\n                    testResults: [],\r\n                    returnedResults: [],\r\n                    expectedResults: getExpectedResults(problemData),\r\n                    parseError: \"Unbalanced brackets. Extra '}' found.\",\r\n                    errorLine: lineNum,\r\n                    runtimeError: \"\",\r\n                    output: \"\",\r\n                    ranSuccessfully: false\r\n                };\r\n            }\r\n        }\r\n\r\n        if (brackets !== 0) {\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"Unbalanced brackets. Missing '}'.\",\r\n                errorLine: lineNum,\r\n                runtimeError: \"\",\r\n                output: \"\",\r\n                ranSuccessfully: false\r\n            };\r\n        }\r\n\r\n        if (!foundFirstBracket) {\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"No function found. We expected to see at least one pair of '{}'.\",\r\n                errorLine: lineNum,\r\n                runtimeError: \"\",\r\n                output: \"\",\r\n                ranSuccessfully: false\r\n            };\r\n        }\r\n\r\n        if (characterAfterLastBracket.value) {\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"You have stray character(s) after the last '}'.\",\r\n                errorLine: characterAfterLastBracket.lineNum,\r\n                runtimeError: \"\",\r\n                output: \"\",\r\n                ranSuccessfully: false\r\n            };\r\n        }\r\n    }\r\n\r\n    // Check that the function signature is correct\r\n    {\r\n        let functionSignature = userCode.split('{')[0];\r\n        let tokens = tokenizeFunctionSignature(functionSignature);\r\n\r\n        let expectedFunctionSignature = problemData.solutionCode.split('{')[0];\r\n        let expectedTokens = tokenizeFunctionSignature(expectedFunctionSignature);\r\n\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            if (tokens[i].str !== expectedTokens[i].str) {\r\n\r\n                let parseError = \"Function signature does not match the expected signature. \";\r\n                if (i === 0) {\r\n                    parseError += \"\\nThe function signature should begin with `\" + expectedTokens[i].str + \"` but you have \";\r\n                    if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                        parseError += \"nothing.\";\r\n                    } else {\r\n                        parseError += \"`\" + tokens[i].str + \"`.\";\r\n                    }\r\n                } else {\r\n                    if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                        parseError += \"Expected: `\" + expectedTokens[i].str + \"` but got nothing.\";\r\n                    } else {\r\n                        parseError += \"Expected: `\" + expectedTokens[i].str + \"` after `\" + tokens.slice(0, i)\r\n                            .map(t => t.str).join(\" \") + \"` but got: `\" + tokens[i].str + \"`.\";\r\n                    }\r\n                }\r\n                return {\r\n                    testResults: [],\r\n                    returnedResults: [],\r\n                    expectedResults: getExpectedResults(problemData),\r\n                    parseError,\r\n                    errorLine: tokens[i].lineNum,\r\n                    runtimeError: \"\",\r\n                    output: \"\",\r\n                    ranSuccessfully: false\r\n                };\r\n            }\r\n        }\r\n\r\n        if (tokens.length !== expectedTokens.length) {\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"Function signature does not match the expected signature. \" +\r\n                    \"Expected: \" + expectedFunctionSignature + \" but got: \" + functionSignature,\r\n                errorLine: tokens[tokens.length - 1].lineNum,\r\n                runtimeError: \"\",\r\n                output: \"\",\r\n                ranSuccessfully: false\r\n            };\r\n        }\r\n    }\r\n\r\n    // We need to look for all the loops (for, while, do-while) and insert code to count the number of iterations.\r\n    // If the number of iterations exceeds 10000, we'll stop the code and return an error.\r\n    // This is to prevent infinite loops.\r\n\r\n    function findLoops(code: string) {\r\n        const loopRegex = /\\b(for|while|do\\s*while)\\s*\\((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)\\s*\\{/g;\r\n        const loops = [];\r\n        let match;\r\n\r\n        while ((match = loopRegex.exec(code)) !== null) {\r\n            loops.push({\r\n                type: match[1],\r\n                start: match.index,\r\n                end: findLoopEndIndex(code, match.index + match[0].length)\r\n            });\r\n        }\r\n\r\n        return loops;\r\n    }\r\n\r\n    function findLoopEndIndex(code: string, startIndex: number) {\r\n        let level = 1;\r\n        for (let i = startIndex; i < code.length; i++) {\r\n            if (code[i] === '{') {\r\n                level++;\r\n            } else if (code[i] === '}') {\r\n                level--;\r\n                if (level === 0) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1; // If loop end is not found\r\n    }\r\n\r\n\r\n    let loopCounterExtraLines: number[] = []\r\n\r\n    let loops = findLoops(userCode);\r\n    for (let i = 0; i < loops.length; i++) {\r\n        let loop = loops[i];\r\n        let loopHeaderStart = loop.start;\r\n        let loopHeaderEnd = userCode.indexOf('{', loopHeaderStart) + 1;\r\n\r\n        let loopHeader = userCode.substring(loopHeaderStart, loopHeaderEnd);\r\n        let preLoopCode = userCode.substring(0, loopHeaderStart);\r\n        let postLoopHeader = userCode.substring(loopHeaderEnd);\r\n\r\n        let lineOfCounter = preLoopCode.split('\\n').length;\r\n        let linePastLoopHeader = preLoopCode.split('\\n').length + loopHeader.split('\\n').length;\r\n\r\n        let loopCounterVar = \"loopCounter\" + crypto.randomUUID().replace(/-/g, '');\r\n        let userCodeAddPreLoop = `let ${loopCounterVar} = 0;\\n`;\r\n        let userCodeAddPostLoop = `if (${loopCounterVar}++ > 10000) { throw new Error(\"Infinite loop detected. Execution stopped.\"); }\\n`;\r\n        userCode = preLoopCode + userCodeAddPreLoop + loopHeader + userCodeAddPostLoop + postLoopHeader;\r\n\r\n        loopCounterExtraLines.push(lineOfCounter);\r\n        loopCounterExtraLines.push(linePastLoopHeader);\r\n\r\n        let addedChars = userCodeAddPreLoop.length + userCodeAddPostLoop.length;\r\n        //Adjust the line numbers of the loops\r\n        for (let j = i + 1; j < loops.length; j++) {\r\n            loops[j].start += addedChars;\r\n            loops[j].end += addedChars;\r\n        }\r\n    }\r\n\r\n    let solutionCode = problemData.solutionCode;\r\n    let resultsArrayName = \"results\" + crypto.randomUUID().replace(/-/g, '');\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${resultsArrayName} = [] || [];\r\nlet ${expectedResultsArrayName} = [] || [];\r\n    `;\r\n\r\n    let userCodeLineNumbersBegin: number[] = [];\r\n\r\n    let userCodeLineNumbersEnd: number[] = [];\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests);\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We need to run that twice:\r\n        //  - Once with the solution code\r\n        //  - Once with the user's code\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                {\r\n${solutionCode}\r\n                    try {\r\n                        expected = ${getResult}\r\n                    } catch (e) {\r\n                        expected = e;\r\n                    }\r\n                }\r\n                {\r\n                `;\r\n        userCodeLineNumbersBegin.push(codeToRun.split('\\n').length);\r\n        codeToRun += userCode;\r\n        userCodeLineNumbersEnd.push(codeToRun.split('\\n').length);\r\n\r\n        codeToRun += `\r\n                    try {\r\n                        result = ${getResult}\r\n                    } catch (e) {\r\n                        result = e;\r\n                    }\r\n                }\r\n            }\r\n            ${resultsArrayName}.push(result);\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return [${resultsArrayName}, ${expectedResultsArrayName}];\r\n    `;\r\n\r\n    // eslint-disable-next-line\r\n    let resultsArray: any[] = [];\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n\r\n\r\n    let testResults = new TestResults();\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(codeToRun);\r\n        let out = func();\r\n\r\n        resultsArray = out[0];\r\n        expectedResultsArray = out[1];\r\n        testResults.ranSuccessfully = true;\r\n    } catch (e) {\r\n        testResults.ranSuccessfully = false;\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        testResults.expectedResults = getExpectedResults(problemData);\r\n        if (e instanceof Error) {\r\n            testResults.errorLine = reformatStackTrace(e, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n            console.log(e.stack);\r\n            testResults.runtimeError = e.stack as string;\r\n        } else {\r\n            testResults.runtimeError = e as string;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Check that we've actually run the test (i.e. we have a result)\r\n        if (i >= expectedResultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(\"Unknown\");\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        if (i >= resultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(expectedResultsArray[i].toString());\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        let result = resultsArray[i];\r\n        let expectedResult = expectedResultsArray[i];\r\n\r\n        if (expectedResult instanceof Error) {\r\n            testResults.expectedResults.push(\"Error\");\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            console.error(\"A test case failed to run the solution: \" + expectedResult);\r\n            console.log(\"Test: \" + combinedTests[i]);\r\n            // TODO: Remove the bottom 2 lines\r\n            console.log(\"Solution: \" + problemData.solutionCode);\r\n            console.log(\"User code: \" + userCode);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.expectedResults.push(safeToString(expectedResult));\r\n        }\r\n\r\n        if (result instanceof Error) {\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.Exception);\r\n            // End the stack trace at the user's code\r\n            testResults.errorLine = reformatStackTrace(result, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n\r\n            testResults.runtimeError = result.stack as string;\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.returnedResults.push(safeToString(result));\r\n        }\r\n\r\n        if (result !== expectedResult) {\r\n            testResults.testResults.push(TestResult.Failed);\r\n        } else {\r\n            testResults.testResults.push(TestResult.Passed);\r\n        }\r\n    }\r\n\r\n    return testResults;\r\n}\r\n\r\n\r\nexport function getExpectedResults(problemData: ProblemData): string[] {\r\n    // Parse the solution code and replace the function name with a random name\r\n    let solutionCode = problemData.solutionCode;\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${expectedResultsArrayName} = [] || [];\r\n    \r\n${solutionCode}\r\n    `;\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests);\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                try {\r\n                    expected = ${getResult}\r\n                } catch (e) {\r\n                    expected = e;\r\n                }\r\n            }\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return ${expectedResultsArrayName}\r\n    `;\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(codeToRun);\r\n        expectedResultsArray = func();\r\n    } catch (e: any) {\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        console.log(\"Solution: \" + problemData.solutionCode);\r\n        return [];\r\n    }\r\n\r\n    return expectedResultsArray.map(result => safeToString(result));\r\n}","import {Marked} from \"marked\";\r\nimport {markedHighlight} from \"marked-highlight\";\r\nimport hljs from \"highlight.js/lib/common\";\r\nimport React, {lazy, Suspense, useEffect, useState} from \"react\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {HelpBoxAndButton} from \"./Help\";\r\nimport {useParams} from \"react-router-dom\";\r\nimport 'katex/dist/katex.min.css';\r\nimport {getUserName} from \"../auth/AuthHelper\";\r\nimport {getExpectedResults, TestResult, TestResults, testUserCode} from \"./CodeRunner\";\r\nimport {Button, Popover, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme, mutedButtonTheme} from \"../App\";\r\nimport markedKatex from \"marked-katex-extension\";\r\nimport {parseProblem, ProblemData, TestCase} from \"./ProblemParse\";\r\n\r\nhljs.registerAliases([\"\"], {languageName: \"javascript\"})\r\n\r\nconst Editor = lazy(() => import(\"./Editor\"));\r\nexport const marked = new Marked(\r\n    markedHighlight({\r\n        langPrefix: 'hljs language-',\r\n        highlight(code, lang, info) {\r\n            const language = hljs.getLanguage(lang) ? lang : 'plaintext';\r\n            return hljs.highlight(code, {language}).value;\r\n        }\r\n    })\r\n);\r\n\r\nconst options = {\r\n    throwOnError: false,\r\n    displayMode: false,\r\n};\r\n\r\nmarked.use(markedKatex(options));\r\n\r\nexport function saveUserData(problemData: ProblemData, userData: UserData) {\r\n    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n        console.error(\"User data is being saved with no code\");\r\n    }\r\n\r\n    localStorage.setItem(getStorageKey(problemData.id, getUserName()), JSON.stringify(userData));\r\n}\r\n\r\nfunction getStorageKey(id: string, userName: string | undefined) {\r\n    return \"problem \" + id;\r\n}\r\n\r\nexport default function Problem() {\r\n    const [problemData, setProblemData] = useState(null as unknown as ProblemData);\r\n    const {\"*\": id} = useParams();\r\n    const [userData, setUserData] = useState(null as unknown as UserData);\r\n    const [helpResponse, setHelpResponse] = useState(\"When you press \\\"I'm stuck\\\", the AI tutor will respond here.\");\r\n    const [magicLinksHover, setMagicLinks] = useState({\r\n        anchorEl: null as (HTMLElement | null),\r\n        magicLink: \"\",\r\n    })\r\n\r\n    function onCodeSubmit() {\r\n        return onSubmission(problemData, userData, setUserData);\r\n    }\r\n\r\n    let normalizedId = id?.toLowerCase();\r\n    normalizedId?.trim()\r\n    if (normalizedId?.startsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(1)\r\n    }\r\n\r\n    if (normalizedId?.endsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(0, normalizedId.length - 1)\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (normalizedId !== undefined) {\r\n            fetch(process.env.PUBLIC_URL + \"/problems/\" + normalizedId + \".md\")\r\n                .then(async r => {\r\n                    let text = await r.text()\r\n                    if (!r.ok || !text.startsWith(\"#\")) {\r\n                        throw new Error(\"Failed to fetch problem data\");\r\n                    } else {\r\n                        return text;\r\n                    }\r\n                })\r\n                .then(async text => {\r\n                    // @ts-ignore - we've check that the id isn't undefined\r\n                    let problemData = parseProblem(text, normalizedId);\r\n                    let userData = getUserData(normalizedId, getUserName());\r\n\r\n                    // set the template data if the user has not saved any data\r\n                    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n                        console.log(\"First time loading problem, setting template data\");\r\n                        if (problemData.displayAbove !== \"\" && problemData.displayBelow !== \"\") {\r\n                            userData.currentCode = problemData.displayAbove + \"\\n\\t\\n\" + problemData.displayBelow;\r\n                        }\r\n                    }\r\n\r\n                    if (userData.testResults === undefined || userData.testResults === null || userData.testResults.expectedResults.length === 0) {\r\n                        console.log(\"First time loading problem, getting expected results\");\r\n                        userData.testResults = new TestResults()\r\n                        userData.testResults.expectedResults = getExpectedResults(problemData);\r\n\r\n                    }\r\n\r\n                    setProblemData(problemData);\r\n                    setUserData(userData);\r\n                })\r\n                .catch(e => {\r\n                    console.error(e);\r\n                    let problemData = new ProblemData();\r\n                    problemData.title = \"Failed to load problem \" + normalizedId;\r\n                    setProblemData(problemData);\r\n                });\r\n        }\r\n    }, [normalizedId]);\r\n\r\n\r\n    if (problemData === null || userData === null) {\r\n        if (problemData != null && problemData.title !== undefined && problemData.title.startsWith(\"Failed to load problem\") && normalizedId !== undefined) {\r\n            return <div>Failed to load problem {normalizedId}</div>;\r\n        }\r\n        if (normalizedId !== undefined) {\r\n            return <div>Loading...</div>;\r\n        } else {\r\n            return <div>A problem wasn't specified</div>;\r\n        }\r\n    }\r\n\r\n    let hljsLang = problemData.codeLang;\r\n    if (hljsLang === \"\") {\r\n        hljsLang = \"plaintext\";\r\n    }\r\n\r\n    let descParsed = DOMPurify.sanitize(marked.parse(problemData.preProblemDescription + \"\\n\\n\" + problemData.description) as string);\r\n\r\n    const handlePopoverOpen = (event: React.MouseEvent<HTMLElement>, magicLink: string) => {\r\n        setMagicLinks({\r\n            anchorEl: event.currentTarget as HTMLElement,\r\n            magicLink: magicLink\r\n        });\r\n    };\r\n\r\n    const handlePopoverClose = () => {\r\n        setMagicLinks({\r\n            anchorEl: null,\r\n            magicLink: magicLinksHover.magicLink\r\n        });\r\n    };\r\n\r\n    const open = Boolean(magicLinksHover.anchorEl);\r\n\r\n\r\n    let testsDisplay = [];\r\n\r\n    for (let i = 0; i < problemData.tests.length; i++) {\r\n        testsDisplay.push(getTestElement(problemData.tests[i],\r\n            userData.testResults.expectedResults[i],\r\n            userData.testResults.returnedResults[i],\r\n            userData.testResults.testResults[i],\r\n            handlePopoverOpen, handlePopoverClose));\r\n    }\r\n\r\n    let testsDisplayJSX = <div>There are no visible test cases</div>;\r\n    if (testsDisplay.length > 0) {\r\n        testsDisplayJSX = <ul className=\"\">\r\n            {testsDisplay.map((test, i) => <li key={i}>{test}</li>)}\r\n        </ul>\r\n    }\r\n\r\n\r\n    let hiddenTestText: string;\r\n    if (userData.testResults.testResults.length === 0) {\r\n        hiddenTestText = \"Hidden tests will be run when you submit your code\";\r\n    } else {\r\n        let totalHiddenTests = problemData.hiddenTests.length;\r\n        let hiddenTestsPassed = 0;\r\n        for (let i = 0; i < problemData.hiddenTests.length; i++) {\r\n            if (userData.testResults.testResults[i + problemData.tests.length] === TestResult.Passed) {\r\n                hiddenTestsPassed++;\r\n            }\r\n        }\r\n        hiddenTestText = hiddenTestsPassed + \" / \" + totalHiddenTests + \" hidden tests passed\";\r\n    }\r\n\r\n    // Callback when the user updates their code\r\n    function updateUserCode(value: string) {\r\n        userData.currentCode = value;\r\n        saveUserData(problemData, userData);\r\n    }\r\n\r\n    let errorText: string = \"\"\r\n    let problemSolved = userData.testResults.testResults.every(result => result === TestResult.Passed) &&\r\n        userData.testResults.testResults.length === userData.testResults.expectedResults.length;\r\n\r\n    if (!userData.testResults.ranSuccessfully) {\r\n        if (userData.testResults.parseError !== \"\") {\r\n            errorText += \"We couldn't run your code due to a syntax error on line \" + userData.testResults.errorLine + \".\\n\";\r\n            errorText += indentText(userData.testResults.parseError, 1);\r\n        } else if (userData.testResults.runtimeError !== \"\") {\r\n            errorText += \"Something went wrong trying to run you code\"\r\n            if (userData.testResults.errorLine !== -1) {\r\n                errorText += \" on line \" + userData.testResults.errorLine + \".\\n\";\r\n            } else {\r\n                errorText += \".\\n\";\r\n            }\r\n            errorText += indentText(userData.testResults.runtimeError, 1);\r\n        } else {\r\n            errorText += \"No error message was provided.\"\r\n        }\r\n    }\r\n\r\n    errorText = errorText.replace(/\\n/g, \"<br>\");\r\n    errorText = DOMPurify.sanitize(errorText);\r\n\r\n    let {helpButton, helpBox} =\r\n        HelpBoxAndButton(problemData, setUserData, onCodeSubmit, helpResponse, setHelpResponse);\r\n\r\n    let nextProblem;\r\n    if (problemData.nextProblemId !== \"\" && problemData.nextProblemId.toLowerCase() !== \"nothing\") {\r\n        nextProblem = <ThemeProvider theme={mutedButtonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color={problemSolved ? \"secondary\" : \"primary\"}\r\n                    href={\"/problem/\" + problemData.nextProblemId}\r\n                    className={\"nextProblemButton\"}>\r\n                Next Problem\r\n            </Button>\r\n        </ThemeProvider>\r\n    } else {\r\n        nextProblem = <div/>\r\n    }\r\n\r\n\r\n    let highlightHover = hljs.highlight(magicLinksHover.magicLink, {language: hljsLang});\r\n    let hoverHtml = DOMPurify.sanitize(highlightHover.value.replace(/\\n/g, \"<br>\"));\r\n\r\n    return (\r\n        <div className=\"ml-5 flex-row\">\r\n            <div className=\"text-7xl font-bold pt-1 pb-5\">{problemData.title}</div>\r\n            <div className=\"w-1/2\" dangerouslySetInnerHTML={{__html: descParsed}}/>\r\n            <div className=\"flex flex-row justify-between h-auto pt-2\">\r\n                <div className=\"w-1/2 h-[calc(100vh*0.80)]\">\r\n                    <Suspense fallback={<div className={\"italic text-gray-300\"}>The Editor is loading...</div>}>\r\n                        <Editor\r\n                            lang={problemData.codeLang}\r\n                            onChange={(value) => updateUserCode(value)}\r\n                            defaultValue={userData.currentCode}\r\n                        />\r\n                    </Suspense>\r\n\r\n                    <div className=\"pt-2\">\r\n                        {nextProblem}\r\n                    </div>\r\n                </div>\r\n                <div className=\"w-1/2 pl-4 pr-4\">\r\n                    <div className=\"text-3xl font-bold w-1/3\"> Tests</div>\r\n                    {testsDisplayJSX}\r\n                    <p className=\"Problem-hidden-tests\">\r\n                        {hiddenTestText}\r\n                    </p>\r\n                    <SubmitButton onClick={onCodeSubmit}/> {helpButton}\r\n                    <div className=\"text-error-red\" dangerouslySetInnerHTML={{__html: errorText}}/>\r\n                    {helpBox}\r\n                </div>\r\n            </div>\r\n            <Popover\r\n                id=\"mouse-over-popover\"\r\n                sx={{\r\n                    pointerEvents: 'none',\r\n                }}\r\n                open={open}\r\n                anchorEl={magicLinksHover.anchorEl}\r\n                anchorOrigin={{\r\n                    vertical: 'bottom',\r\n                    horizontal: 'left',\r\n                }}\r\n                transformOrigin={{\r\n                    vertical: 'top',\r\n                    horizontal: 'left',\r\n                }}\r\n                onClose={handlePopoverClose}\r\n                disableRestoreFocus\r\n            >\r\n                <div className=\"p-2 bg-basically-black text-[#abb2bf]\"\r\n                     style={{\r\n                         fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\r\n                         whiteSpace: \"pre-wrap\",\r\n                     }}\r\n                     dangerouslySetInnerHTML={{__html: hoverHtml}\r\n                     }/>\r\n            </Popover>\r\n        </div>\r\n    );\r\n}\r\n\r\n/**\r\n * Returns a JSX element for a test case\r\n */\r\nfunction getTestElement(test: TestCase, expectedResult: string, actualResult: string, result: TestResult | undefined,\r\n                        handlePopoverOpen: (event: React.MouseEvent<HTMLElement>, magicLink: string) => void,\r\n                        handlePopoverClose: () => void) {\r\n    let resultText = result === undefined ? \"Not Run\" : result.toString();\r\n    if (result === TestResult.Failed) {\r\n        resultText += \" (Returned: \" + actualResult + \")\";\r\n    }\r\n\r\n    let bgColor = result === TestResult.Passed ? \"bg-test-passed\" : \"bg-test-failed\";\r\n\r\n    class MagicLink {\r\n        text: string;\r\n        link: string;\r\n\r\n        constructor(text: string, link: string) {\r\n            this.text = text;\r\n            this.link = link;\r\n        }\r\n    }\r\n\r\n    let testStringPart: (string | MagicLink)[] = [];\r\n\r\n    let testString = test.display;\r\n\r\n    for (const entries of test.magicLinks.values()) {\r\n        let key = entries.key;\r\n        let value = entries.value;\r\n\r\n        let index = testString.indexOf(key);\r\n\r\n        if (index === -1) {\r\n            console.error(\"Failed to find magic link in test string: \" + key);\r\n            continue;\r\n        }\r\n        if (index > 0) {\r\n            testStringPart.push(testString.substring(0, index));\r\n            testString = testString.substring(index);\r\n        }\r\n        testStringPart.push(new MagicLink(key, value));\r\n        testString = testString.substring(key.length);\r\n    }\r\n\r\n    testStringPart.push(testString);\r\n\r\n\r\n    let div = <div className={\"mb-2 text-black font-bold pl-1 \" + bgColor}>\r\n        {testStringPart.map((part, i) => {\r\n            if (part instanceof MagicLink) {\r\n                return <span key={i} className={\"text-purple-800 underline\"}\r\n                             onMouseEnter={(e) => handlePopoverOpen(e, part.text + \" = \" + part.link)}\r\n                             onMouseLeave={handlePopoverClose}>{part.text}</span>\r\n            } else {\r\n                return <span key={i}>{part}</span>\r\n            }\r\n        })}\r\n        <span>\r\n            {\" ➔\"} {expectedResult} : {resultText}\r\n        </span>\r\n    </div>\r\n\r\n\r\n    return (\r\n        div\r\n    );\r\n}\r\n\r\n/**\r\n * Returns the text indented by a number of tabs\r\n */\r\nfunction indentText(text: string, indent: number) {\r\n    let indentText = \"<span style='margin-left: \" + (indent * 2) + \"em'> </span>\";\r\n\r\n    return text.split(\"\\n\").map(line => indentText + line).join(\"\\n\");\r\n}\r\n\r\nexport class UserData {\r\n    history: string[] = [];\r\n    requestHelpHistory: string[] = [];\r\n    testResults: TestResults = new TestResults();\r\n    lastUpdated: Date = new Date();\r\n    currentCode: string = null as unknown as string;\r\n    aiRememberResponse: string[] = [];\r\n\r\n    constructor(history: string[] = [], requestHelpHistory: string[] = [], testResults: TestResults = new TestResults(), lastUpdated: Date = new Date(), currentCode: string = \"\", aiRememberResponse: string[] = []) {\r\n        this.history = history;\r\n        this.testResults = testResults;\r\n        this.requestHelpHistory = requestHelpHistory;\r\n        this.lastUpdated = lastUpdated;\r\n        this.currentCode = currentCode;\r\n        this.aiRememberResponse = aiRememberResponse;\r\n    }\r\n}\r\n\r\n/**\r\n * Loads the user data from local storage\r\n * @param id The id of the problem\r\n * @param userName The username of the user\r\n */\r\nfunction getUserData(id: string | undefined, userName: string | undefined) {\r\n    if (id === undefined) {\r\n        console.error(\"No problem id was specified, so no user data could be retrieved.\");\r\n        return new UserData();\r\n    }\r\n    let userData = localStorage.getItem(getStorageKey(id, userName));\r\n    if (userData === null) {\r\n        // try to get the data without the username\r\n        userData = localStorage.getItem(getStorageKey(id, undefined));\r\n        if (userData !== null) {\r\n            console.log(\"Got user data without username\");\r\n        }\r\n    }\r\n    if (userData === null) {\r\n        return new UserData();\r\n    }\r\n\r\n    return JSON.parse(userData) as UserData;\r\n}\r\n\r\nfunction SubmitButton({onClick}: { onClick: () => void }) {\r\n    return (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"primary\"\r\n                    onClick={onClick}\r\n                    className={\"submitButton\"}\r\n            >\r\n                Test Code\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n}\r\n\r\n\r\nfunction onSubmission(problemData: ProblemData, userData: UserData, setUserData: (data: UserData) => void) {\r\n    if (userData.history.length === 0) {\r\n        // First submission\r\n        userData.history.push(userData.currentCode);\r\n    } else {\r\n        let lastSubmission = userData.history[userData.history.length - 1];\r\n        if (lastSubmission !== userData.currentCode) {\r\n            userData.history.push(userData.currentCode);\r\n        }\r\n    }\r\n\r\n    userData.lastUpdated = new Date();\r\n\r\n    let testResults = testUserCode(userData, problemData);\r\n\r\n    let newUserData = new UserData(\r\n        userData.history,\r\n        userData.requestHelpHistory,\r\n        testResults,\r\n        new Date(),\r\n        userData.currentCode,\r\n        userData.aiRememberResponse\r\n    )\r\n    setUserData(newUserData);\r\n    saveUserData(problemData, newUserData);\r\n    return newUserData;\r\n}"],"names":["ProblemData","constructor","id","title","preProblemDescription","description","tests","hiddenTests","displayAbove","displayBelow","solution","solutionCode","codeLang","nextProblemId","KeyValue","key","value","this","extractTestCases","tokens","length","absorbWhitespace","type","testString","shift","text","trim","split","flatMap","s","functionCall","indexBeginParen","indexOf","indexEndParen","i","console","error","params","substring","map","repeatTimes","displayAs","endsWith","magicLinks","param","match","RegExp","concat","undefined","index","bracketCount","curlyCount","doubleQuoteCount","singleQuoteCount","backtickCount","c","setKeyValue","metaData","toLowerCase","num","parseInt","isNaN","includes","push","test","display","kvList","kv","removeNextHeading","expectedText","removeTillNextType","heading","Error","LOADING_MESSAGE","functionHeaderOffset","TestResult","TestResults","testResults","returnedResults","expectedResults","parseError","errorLine","runtimeError","output","ranSuccessfully","StringLineNum","str","lineNum","tokenizeFunctionSignature","signature","tokenChars","bufferStartIndex","filter","token","reformatStackTrace","result","userCodeLineNumbersBegin","userCodeLineNumbersEnd","addedLines","stackTrace","stack","stackTraceLines","j","thisLine","startsWith","slice","regex","replace","matches","lineNumber","userCodeLineNumberBegin","userCodeLineNumberEnd","newLineNumber","lineNumberOffset","columnNumber","newLine","join","safeToString","expectedResult","toString","getExpectedResults","problemData","expectedResultsArrayName","crypto","randomUUID","codeToRun","combinedTests","testSplitByLines","setupCode","getResult","expectedResultsArray","Function","func","e","log","hljs","registerAliases","languageName","Editor","lazy","marked","Marked","markedHighlight","langPrefix","highlight","code","lang","info","language","getLanguage","saveUserData","userData","currentCode","localStorage","setItem","getStorageKey","getUserName","JSON","stringify","userName","Problem","_normalizedId","_normalizedId2","_normalizedId3","setProblemData","useState","useParams","setUserData","helpResponse","setHelpResponse","magicLinksHover","setMagicLinks","anchorEl","magicLink","onCodeSubmit","history","lastUpdated","Date","userCode","brackets","foundFirstBracket","whitespaceRegex","characterAfterLastBracket","functionSignature","expectedFunctionSignature","expectedTokens","t","findLoopEndIndex","startIndex","level","loopCounterExtraLines","loops","loopRegex","exec","start","end","findLoops","loopHeaderStart","loopHeaderEnd","loopHeader","preLoopCode","postLoopHeader","lineOfCounter","linePastLoopHeader","loopCounterVar","userCodeAddPreLoop","userCodeAddPostLoop","addedChars","resultsArrayName","resultsArray","out","NotRun","Exception","Failed","Passed","testUserCode","newUserData","UserData","requestHelpHistory","aiRememberResponse","onSubmission","normalizedId","useEffect","fetch","then","async","r","ok","lexer","depth","raw","problem","splitProblem","parseProblem","getItem","parse","getUserData","catch","_jsxs","children","_jsx","hljsLang","descParsed","DOMPurify","handlePopoverOpen","event","currentTarget","handlePopoverClose","open","Boolean","testsDisplay","getTestElement","hiddenTestText","testsDisplayJSX","className","totalHiddenTests","hiddenTestsPassed","errorText","problemSolved","every","indentText","nextProblem","helpButton","helpBox","runTests","response","setResponse","button","ThemeProvider","theme","buttonTheme","Button","variant","color","onClick","setAttribute","isLoggedIn","getToken","target","method","headers","accept","body","json","expire_logins","expireToken","logIn","status","rememberingResponse","removeAttribute","dangerouslySetInnerHTML","__html","HelpBoxAndButton","mutedButtonTheme","href","highlightHover","hoverHtml","Suspense","fallback","onChange","updateUserCode","defaultValue","SubmitButton","Popover","sx","pointerEvents","anchorOrigin","vertical","horizontal","transformOrigin","onClose","disableRestoreFocus","style","fontFamily","whiteSpace","actualResult","resultText","bgColor","MagicLink","link","testStringPart","entries","values","part","onMouseEnter","onMouseLeave","indent","line","use","markedKatex","throwOnError","displayMode","arguments","_ref"],"sourceRoot":""}