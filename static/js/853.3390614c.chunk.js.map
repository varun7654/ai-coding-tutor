{"version":3,"file":"static/js/853.3390614c.chunk.js","mappings":"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","sources":["problem/ProblemParse.ts","problem/Help.tsx","problem/CodeRunner.ts","problem/Problem.tsx"],"sourcesContent":["import {marked} from \"./Problem\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\nexport class ProblemData {\r\n    id: string = \"\";\r\n    title: string = 'Loading...';\r\n    preProblemDescription: string = \"\";\r\n    description: string = \"\";\r\n    tests: TestCase[] = [];\r\n    hiddenTests: TestCase[] = [];\r\n    displayAbove: string = \"\";\r\n    displayBelow: string = \"\";\r\n    solution: string = \"\";\r\n    solutionCode: string = \"\";\r\n    codeLang: string = \"\";\r\n    nextProblemId: string = \"\";\r\n}\r\n\r\nexport class TestCase {\r\n    test: string;\r\n    display: string;\r\n    magicLinks: KeyValue[];\r\n\r\n    constructor(test: string, display: string, magicLinks: KeyValue[]) {\r\n        this.test = test;\r\n        this.display = display;\r\n        this.magicLinks = magicLinks;\r\n    }\r\n}\r\n\r\nexport class KeyValue {\r\n    key: string;\r\n    value: string;\r\n\r\n    constructor(key: string, value: string) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nexport function parseProblem(text: string, id: string): ProblemData {\r\n    let tokens = marked.lexer(text);\r\n    let title = (tokens.shift() as Tokens.Heading).text;\r\n\r\n    let preProblemDescription = \"\";\r\n    removeTillNextType(tokens, \"heading\"); // Collect everything under the description heading\r\n    if ((tokens[0] as Tokens.Heading).text === \"Context\") {\r\n        tokens.shift();\r\n        while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n            preProblemDescription += ((tokens.shift() as Token).raw);\r\n        }\r\n    }\r\n\r\n    // Collect everything under the description heading\r\n    removeNextHeading(tokens, \"description\"); // Remove the description heading\r\n\r\n    let description = \"\";\r\n    while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1)) {\r\n        description += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Problem\"); // Remove the problem heading\r\n    if (tokens[0].type !== \"code\") {\r\n        console.error(\"Problem Parse: No code block found after problem heading. If no template code is needed, please use a code block with no content (with the correct language).\");\r\n    }\r\n    let problem = tokens.shift() as Tokens.Code;\r\n    if (!problem.lang) {\r\n        console.error(\"Problem Parse: No code language specified for problem \" + id);\r\n    }\r\n    let codeLang = problem.lang ? problem.lang : \"javascript\";\r\n\r\n    let splitProblem = problem.text.split(\"// Your code here\");\r\n\r\n    let displayAbove;\r\n    let displayBelow;\r\n\r\n    if (splitProblem.length === 0 || splitProblem[0].trim() === \"\") {\r\n        console.log(\"Problem Parse: Code block has no content\");\r\n        displayAbove = \"\";\r\n        displayBelow = \"\";\r\n    } else {\r\n        displayAbove = splitProblem[0].trim();\r\n        if (splitProblem.length === 1) {\r\n            displayBelow = \"\";\r\n            console.error(\"Problem Parse: No secondary display content found in problem \" + id +\r\n                \". It is unlikely that this is intentional. Ensure that you have a comment with the text '// Your code here' in the problem description.\");\r\n        } else {\r\n            displayBelow = splitProblem[1].trim();\r\n        }\r\n    }\r\n\r\n\r\n    removeNextHeading(tokens, \"Solution\"); // Remove the solution heading\r\n    absorbWhitespace(tokens);\r\n    let solution = \"\";\r\n    let solutionCode = \"\";\r\n    while (tokens.length > 0 && !(tokens[0].type === \"heading\" && (tokens[0] as Tokens.Heading).depth <= 1)) {\r\n        if (tokens[0].type === \"code\" && solutionCode === \"\") {\r\n            // Get the first code block as the solution code\r\n            solutionCode += (tokens[0] as Tokens.Code).text;\r\n        }\r\n        solution += ((tokens.shift() as Token).raw);\r\n    }\r\n\r\n    removeNextHeading(tokens, \"Test Cases\"); // Remove the tests heading\r\n    let tests: TestCase[] = [];\r\n    extractTestCases(tokens, tests);\r\n\r\n    removeNextHeading(tokens, \"Hidden Test Cases\"); // Remove the hidden tests heading\r\n    let hiddenTests: TestCase[] = [];\r\n    extractTestCases(tokens, hiddenTests);\r\n\r\n    removeNextHeading(tokens, \"Next\");\r\n    let nextProblemId;\r\n    if (tokens.length === 0 || tokens[0].type !== \"paragraph\") {\r\n        nextProblemId = \"nothing\";\r\n    } else {\r\n        nextProblemId = (tokens.shift() as Tokens.Paragraph).text;\r\n        nextProblemId = nextProblemId.trim();\r\n        if (nextProblemId.startsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(1);\r\n        }\r\n        if (nextProblemId.endsWith(\"/\")) {\r\n            nextProblemId = nextProblemId.substring(0, nextProblemId.length - 1);\r\n        }\r\n        if (nextProblemId === \"\") {\r\n            nextProblemId = \"nothing\";\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        id,\r\n        title,\r\n        preProblemDescription,\r\n        description,\r\n        tests,\r\n        hiddenTests,\r\n        displayAbove,\r\n        displayBelow,\r\n        solution,\r\n        solutionCode,\r\n        codeLang,\r\n        nextProblemId\r\n    };\r\n}\r\n\r\nfunction extractTestCases(tokens: Token[], tests: TestCase[]) {\r\n    // Tests are formatted as a list of functions in a code block with the expected result below it\r\n    while (tokens.length > 0) {\r\n        absorbWhitespace(tokens);\r\n        if (tokens.length === 0 || tokens[0].type !== \"code\") break;\r\n        let test = tokens.shift() as Tokens.Code;\r\n\r\n        let testString = test.text.trim();\r\n        let split = testString.split(\"\\n\").flatMap((s) => s.trim());\r\n        let functionCall = split[split.length - 1];\r\n        let indexBeginParen = functionCall.indexOf(\"(\");\r\n        let indexEndParen = -1;\r\n        for (let i = functionCall.length - 1; i >= 0; i--) {\r\n            if (functionCall[i] === \")\") {\r\n                indexEndParen = i;\r\n                break;\r\n            }\r\n        }\r\n        if (indexBeginParen === -1 || indexEndParen === -1) {\r\n            console.error(\"Failed to parse function call (Magic Links will not work!): \" + functionCall);\r\n            continue;\r\n        }\r\n        let params = functionCall.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n        absorbWhitespace(tokens);\r\n        let repeatTimes = 1;\r\n        let displayAs = functionCall;\r\n        // Remove the last ; if it exists\r\n        if (displayAs.endsWith(\";\")) {\r\n            displayAs = displayAs.substring(0, displayAs.length - 1);\r\n        }\r\n\r\n        let magicLinks: KeyValue[] = [];\r\n\r\n        for (let param of params) {\r\n            // See if we can find where the parameter is defined in the code block\r\n            // We want to match let param = value;\r\n            let match = testString.match(new RegExp(`let\\\\s+${param}\\\\s*=\\\\s*`));\r\n            if (match !== null && match.index !== undefined) {\r\n                let value = testString.substring(match.index + match[0].length).trim();\r\n                let bracketCount = 0;\r\n                let curlyCount = 0;\r\n                let doubleQuoteCount = 0;\r\n                let singleQuoteCount = 0;\r\n                let backtickCount = 0;\r\n                for (let i = 0; i < value.length; i++) {\r\n                    let c = value[i];\r\n                    if (c === \"(\") {\r\n                        bracketCount++;\r\n                    } else if (c === \")\") {\r\n                        bracketCount--;\r\n                    } else if (c === \"{\") {\r\n                        curlyCount++;\r\n                    } else if (c === \"}\") {\r\n                        curlyCount--;\r\n                    } else if (c === \"\\\"\") {\r\n                        doubleQuoteCount++;\r\n                    } else if (c === \"'\") {\r\n                        singleQuoteCount++;\r\n                    } else if (c === \"`\") {\r\n                        backtickCount++;\r\n                    }\r\n                    if (bracketCount === 0 && curlyCount === 0 && doubleQuoteCount % 2 === 0 && singleQuoteCount % 2 === 0 && backtickCount % 2 === 0 && c === \";\" && i !== value.length - 1) {\r\n                        value = value.substring(0, i);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                setKeyValue(magicLinks, param, value);\r\n            }\r\n        }\r\n\r\n        // @ts-ignore - ts seems to not believe that type could be paragraph\r\n        while (tokens.length > 0 && tokens[0].type === \"paragraph\") {\r\n            let metaData = (tokens.shift() as Tokens.Paragraph).text.trim();\r\n\r\n            let split = metaData.split(\"=\").map(s => s.trim());\r\n            if (split.length !== 2) {\r\n                console.error(\"Failed to parse metadata: \" + metaData);\r\n                continue;\r\n            }\r\n            let key = split[0].toLowerCase();\r\n            let value = split[1];\r\n\r\n            if (key === \"repeat\") {\r\n                let num = parseInt(value);\r\n                if (isNaN(num)) {\r\n                    console.error(\"Failed to parse repeat value: \" + value);\r\n                } else {\r\n                    repeatTimes = num;\r\n                }\r\n            } else if (key === \"displayas\") {\r\n                displayAs = value;\r\n\r\n                let indexBeginParen = functionCall.indexOf(\"(\");\r\n                let indexEndParen = -1;\r\n                for (let i = displayAs.length - 1; i >= 0; i--) {\r\n                    if (displayAs[i] === \")\") {\r\n                        indexEndParen = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (indexBeginParen === -1 || indexEndParen === -1) {\r\n                    console.error(\"Failed to parse function for displayAs meta call (Magic Links will not work!): \" + displayAs);\r\n                    continue;\r\n                }\r\n                params = displayAs.substring(indexBeginParen + 1, indexEndParen).split(\",\").map(s => s.trim());\r\n\r\n            } else if (params.includes(split[0])) { // We don't want to remove the casing\r\n                let key = split[0];\r\n                let value = split[1];\r\n                if (split[1].length === 0) {\r\n                    // We should look for a code block\r\n                    absorbWhitespace(tokens);\r\n                    if (tokens.length === 0 || tokens[0].type !== \"code\") {\r\n                        console.error(\"Found magic link with nothing after the equals sign & no code block following: \" + split[0]);\r\n                    } else {\r\n                        value = (tokens.shift() as Tokens.Code).text;\r\n                    }\r\n                }\r\n                // This is a parameter\r\n                setKeyValue(magicLinks, key, value);\r\n            } else {\r\n                console.error(\"Unknown metadata key: \" + split[0]);\r\n            }\r\n            absorbWhitespace(tokens);\r\n        }\r\n\r\n        for (let i = 0; i < repeatTimes; i++) {\r\n            tests.push({\r\n                test: testString,\r\n                display: displayAs,\r\n                magicLinks\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction setKeyValue(kvList: KeyValue[], key: string, value: string) {\r\n    for (let kv of kvList) {\r\n        if (kv.key === key) {\r\n            kv.value = value;\r\n            return;\r\n        }\r\n    }\r\n    kvList.push(new KeyValue(key, value));\r\n}\r\n\r\n\r\nexport function removeNextHeading(tokens: Token[], expectedText: string) {\r\n    removeTillNextType(tokens, \"heading\");\r\n    if (tokens.length === 0) {\r\n        new Error(\"Problem Parse: Expected a heading with text: \" + expectedText);\r\n        return;\r\n    } else {\r\n        let heading = tokens.shift() as Tokens.Heading;\r\n        if (heading.text.trim().toLowerCase() === expectedText.trim().toLowerCase()) {\r\n            new Error(\"Problem Parse: Expected a heading with text: \" + expectedText + \" but got: \" + heading.text);\r\n        }\r\n    }\r\n}\r\n\r\nexport function removeTillNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n}\r\n\r\nexport function removeNextType(tokens: Token[], type: string) {\r\n    while (tokens.length > 0 && tokens[0].type !== type) {\r\n        tokens.shift();\r\n    }\r\n    tokens.shift();\r\n}\r\n\r\nexport function absorbWhitespace(tokens: Token[]) {\r\n    while (tokens.length > 0 && tokens[0].type === \"space\") {\r\n        tokens.shift();\r\n    }\r\n}","import React, {ReactElement} from \"react\";\r\nimport {marked, saveUserData, UserData} from \"./Problem\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {expireToken, getToken, isLoggedIn, logIn} from \"../auth/AuthHelper\";\r\nimport {Button, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme} from \"../App\";\r\nimport {ProblemData, removeNextHeading} from \"./ProblemParse\";\r\nimport {Token, Tokens} from \"marked\";\r\n\r\n\r\nexport const LOADING_MESSAGE = \"Requesting help from the AI tutor...\";\r\n\r\nexport const NEXT_HELP_TIME = \"NEXT_HELP_TIME\"\r\n\r\n\r\nexport function HelpBoxAndButton(problemData: ProblemData,\r\n                                 setUserData: (userData: UserData) => void,\r\n                                 runTests: () => UserData,\r\n                                 response: string,\r\n                                 setResponse: (response: string) => void):\r\n    { helpButton: ReactElement, helpBox: ReactElement } {\r\n\r\n    function handleHelpRequest(event: React.MouseEvent<HTMLButtonElement>) {\r\n        event.currentTarget.setAttribute(\"disabled\", \"true\");\r\n\r\n        let userData = runTests();\r\n        if (!isLoggedIn()) {\r\n            setResponse(\"You must be logged in to use the AI tutor. Please log in and try again.\");\r\n            return;\r\n        }\r\n\r\n        let token = getToken();\r\n        let target = event.currentTarget;\r\n        setResponse(LOADING_MESSAGE);\r\n        fetch(\"https://codehelp.api.dacubeking.com/ai-tutor\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"content-type\": \"application/json\",\r\n                \"user-agent\": \"WeCode/1.0.0\",\r\n                accept: \"application/json\",\r\n                \"Authorization\": `token ${token}`\r\n            },\r\n            body: JSON.stringify({\r\n                problemData: problemData,\r\n                userData: userData,\r\n            })\r\n        })\r\n            .then(response => response.json())\r\n            .then((json: {\r\n                status: number,\r\n                prompt: string,\r\n                response: string,\r\n                expire_logins: boolean,\r\n                wait_time: number,\r\n            }) => {\r\n                if (json.expire_logins) {\r\n                    expireToken();\r\n                    logIn();\r\n                    setResponse(\"Your login has expired. Please try again after logging in.\");\r\n                    return;\r\n                }\r\n\r\n                if (json.status === 401) {\r\n                    setResponse(\"You are not authorized to use the AI tutor.\");\r\n                    return;\r\n                }\r\n\r\n                localStorage.setItem(NEXT_HELP_TIME, (Date.now() + json.wait_time * 1000).toString());\r\n\r\n                if (json.status === 429) {\r\n                    setResponse(\"You have made too many requests to the AI tutor. Please try again later.\");\r\n                    // Use the waitTime (seconds) to determine how long to wait before trying again\r\n                    new Promise((resolve) => setTimeout(resolve, json.wait_time * 1000)).then(() => {\r\n                        target.removeAttribute(\"disabled\");\r\n                    });\r\n                    return;\r\n                }\r\n\r\n                if (json.status !== 200) {\r\n                    setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                    target.removeAttribute(\"disabled\");\r\n                    return;\r\n                }\r\n\r\n\r\n                let tokens = marked.lexer(json.response);\r\n                // There are two sections: # Thinking out loud and # My Response\r\n                // We want to display the My Response section\r\n\r\n                // Remove Thinking out loud\r\n                removeNextHeading(tokens, \"Thinking out loud\");\r\n                // Remove the My Response heading\r\n                removeNextHeading(tokens, \"My Response\");\r\n\r\n                // Collect everything under the My Response heading\r\n                let response = \"\";\r\n                while (tokens.length > 0 && (tokens[0].type !== \"heading\" || (tokens[0] as Tokens.Heading).depth > 1 || (tokens[0] as Tokens.Heading).text.trim() !== \"Remembering\")) {\r\n                    response += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                removeNextHeading(tokens, \"Remembering\"); // Remove the Remembering heading\r\n                let rememberingResponse = \"\";\r\n                while (tokens.length > 0) {\r\n                    rememberingResponse += ((tokens.shift() as Token).raw);\r\n                }\r\n\r\n                let newUserData = {\r\n                    ...userData,\r\n                    aiRememberResponse: userData.aiRememberResponse.concat(rememberingResponse),\r\n                }\r\n\r\n                setUserData(\r\n                    newUserData\r\n                );\r\n\r\n                saveUserData(problemData, newUserData);\r\n                setResponse(DOMPurify.sanitize(marked.parse(response) as string));\r\n                new Promise((resolve) => setTimeout(resolve, json.wait_time * 1000)).then(() => {\r\n                    target.removeAttribute(\"disabled\");\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                console.error(error);\r\n                setResponse(\"An error occurred while using the AI tutor. Please try again later.\");\r\n                target.removeAttribute(\"disabled\");\r\n            });\r\n    }\r\n\r\n    let button = (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"secondary\"\r\n                    onClick={handleHelpRequest}\r\n                    className=\"helpButton\"\r\n            >\r\n                I'm stuck!\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n\r\n    let helpBox = (\r\n        <div className=\"AI-help-area border-2  p-2 mt-2 mb-4 mr-2 border-white-pink w-full min-h-20\">\r\n            <p className=\"Code-tutor-response\" dangerouslySetInnerHTML={{__html: response}}/>\r\n        </div>\r\n    );\r\n\r\n\r\n    return {\r\n        helpButton: button,\r\n        helpBox: helpBox\r\n    }\r\n}","import {UserData} from \"./Problem\";\r\nimport {ProblemData} from \"./ProblemParse\";\r\nimport {Log} from \"capture-console-logs/dist/logs\";\r\nimport * as util from \"util\";\r\nimport * as acorn from \"acorn\";\r\n\r\nconst functionHeaderOffset = 2;\r\n\r\nexport enum TestResult {\r\n    Passed = \"Passed\",\r\n    Failed = \"Failed\",\r\n    Exception = \"Exception\",\r\n    NotRun = \"Not run\"\r\n}\r\n\r\nexport class TestResults {\r\n    public testResults: TestResult[] = [];\r\n    public returnedResults: string[] = [];\r\n    public expectedResults: string[] = [];\r\n    public parseError: string = \"\";\r\n    public errorLine: number = -1;\r\n    public runtimeError: string = \"\";\r\n    public outputs: string[][] = [];\r\n    public ranSuccessfully: boolean = true; // Prevents the user from seeing an error message on first load\r\n}\r\n\r\nclass StringLineNum {\r\n    public str: string;\r\n    public lineNum: number;\r\n\r\n    constructor(str: string, lineNum: number) {\r\n        this.str = str;\r\n        this.lineNum = lineNum;\r\n    }\r\n}\r\n\r\nconst CaptureConsole = require(\"capture-console-logs\").default\r\n\r\n\r\n// Function to tokenize a JavaScript function signature\r\nfunction tokenizeFunctionSignature(signature: string): StringLineNum[] {\r\n    let tokens: StringLineNum[] = [];\r\n    let lineNum = 1;\r\n\r\n    const tokenChars = [' ', '(', ')', '{', '}', ':', ',', ';', '\\n'];\r\n\r\n\r\n    let bufferStartIndex = 0;\r\n    for (let i = 0; i < signature.length; i++) {\r\n        if (tokenChars.includes(signature[i])) {\r\n            if (bufferStartIndex !== i) {\r\n                tokens.push(new StringLineNum(signature.substring(bufferStartIndex, i), lineNum));\r\n            }\r\n            // We also need to add the token character as a separate token.\r\n            // Don't add a token for a space character.\r\n            // Don't add a token for a new line character\r\n            // (but if we haven't seen a semicolon, on a line with content, add a token).\r\n            if (signature[i] !== ' ' && signature[i] !== '\\n') {\r\n                tokens.push(new StringLineNum(signature[i], lineNum));\r\n            }\r\n\r\n            if (signature[i] === '\\n') {\r\n                lineNum++;\r\n            }\r\n\r\n            bufferStartIndex = i + 1;\r\n        }\r\n    }\r\n\r\n    // Filter out any empty tokens\r\n    return tokens.filter(token => token.str !== \"\");\r\n}\r\n\r\n/**\r\n * Reformat the stack trace to show the user's code line numbers\r\n * @param result The error object\r\n * @param userCodeLineNumbersBegin The line numbers of the user's code\r\n * @param userCodeLineNumbersEnd The line numbers of the user's code\r\n */\r\nfunction reformatStackTrace(result: Error, userCodeLineNumbersBegin: number[], userCodeLineNumbersEnd: number[], addedLines: number[]): number {\r\n    let stackTrace = result.stack;\r\n    if (stackTrace === undefined) {\r\n        stackTrace = \"\";\r\n    }\r\n    let stackTraceLines = stackTrace.split('\\n');\r\n    // discard after when the line begins with \"at testUserCode\"\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        if (thisLine.startsWith(\"at testUserCode\") || thisLine.startsWith(\"at Function\") || thisLine.startsWith(\"at eval\")) {\r\n            stackTraceLines = stackTraceLines.slice(0, j);\r\n            break;\r\n        }\r\n    }\r\n\r\n    const regex = /eval\\s+at\\s+\\w+\\s+\\(https?:\\/\\/[^)]+\\),\\s+<anonymous>:/g;\r\n\r\n    // remove the (eval at testUserCode (url) <anonymous:) part (keep the line number/col number)\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        stackTraceLines[j] = stackTraceLines[j].replace(regex, \"\");\r\n    }\r\n\r\n    let errorLine = -1\r\n    // Find the line number of the error & adjust line numbers to match the user's code\r\n    for (let j = 0; j < stackTraceLines.length; j++) {\r\n        let thisLine = stackTraceLines[j].trim();\r\n        let matches = thisLine.match(/(\\d+):(\\d+)/);\r\n        if (matches !== null) {\r\n            let lineNumber = parseInt(matches[1]) - functionHeaderOffset; // Retrieve the line number\r\n\r\n            let userCodeLineNumberBegin = -1;\r\n            let userCodeLineNumberEnd = -1;\r\n\r\n            for (let i = 0; i < userCodeLineNumbersBegin.length; i++) {\r\n                if (lineNumber >= userCodeLineNumbersBegin[i] && lineNumber <= userCodeLineNumbersEnd[i]) {\r\n                    userCodeLineNumberBegin = userCodeLineNumbersBegin[i];\r\n                    userCodeLineNumberEnd = userCodeLineNumbersEnd[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (userCodeLineNumberBegin !== -1 && userCodeLineNumberEnd !== -1) {\r\n                let newLineNumber = lineNumber - userCodeLineNumberBegin + 1;\r\n\r\n                let lineNumberOffset = 0;\r\n                for (let i = 0; i < addedLines.length; i++) {\r\n                    if (newLineNumber > addedLines[i]) {\r\n                        lineNumberOffset++;\r\n                    }\r\n                }\r\n\r\n                newLineNumber -= lineNumberOffset;\r\n\r\n                let columnNumber = parseInt(matches[2]); // Retrieve the column number\r\n                let newLine = `${newLineNumber}:${columnNumber}`; // Construct the new line with adjusted line number\r\n                stackTraceLines[j] = thisLine.replace(matches[0], newLine); // Replace the entire matched portion with the new line\r\n                if (errorLine === -1) {\r\n                    errorLine = newLineNumber;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //result.stack += \"\\nNew Stack:\\n\" + stackTraceLines.join('\\n');\r\n    result.stack = stackTraceLines.join('\\n');\r\n    return errorLine;\r\n}\r\n\r\nfunction safeToString(expectedResult: any) {\r\n    if (expectedResult === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    if (expectedResult === null) {\r\n        return \"null\";\r\n    }\r\n    return expectedResult.toString();\r\n}\r\n\r\nexport function testUserCode(userData: UserData, problemData: ProblemData): TestResults {\r\n    let userCode = userData.currentCode;\r\n\r\n    let ast;\r\n    try {\r\n        ast = acorn.parse(userCode, {ecmaVersion: \"latest\", locations: true});\r\n    } catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n            let message = e.message;\r\n\r\n            // @ts-ignore\r\n            if (e.pos === userCode.length) {\r\n                message += \"\\nUnexpected end of input. Check that you have closed all brackets and parentheses.\";\r\n            }\r\n\r\n\r\n            return {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: message,\r\n                // @ts-ignore\r\n                errorLine: e.loc.line,\r\n                runtimeError: \"\",\r\n                outputs: [],\r\n                ranSuccessfully: false\r\n            };\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n\r\n    {\r\n        let missingFunctionError = {\r\n            returnableError: {\r\n                testResults: [],\r\n                returnedResults: [],\r\n                expectedResults: getExpectedResults(problemData),\r\n                parseError: \"You need to define a function with the following signature:\" + problemData.solutionCode.split('{')[0],\r\n                errorLine: 1,\r\n                runtimeError: \"\",\r\n                outputs: [],\r\n                ranSuccessfully: false\r\n            },\r\n            matchedTokens: 0,\r\n            // The levenshteinDistance between the missed token\r\n            levenshteinDistance: 100000\r\n        };\r\n\r\n        let foundFunction = false;\r\n\r\n        fnLoop: for (let func of ast.body) {\r\n            let functionSignature = userCode.substring(func.start, func.end).split('{')[0];\r\n            let tokens = tokenizeFunctionSignature(functionSignature);\r\n\r\n            let expectedFunctionSignature = problemData.solutionCode.split('{')[0];\r\n            let expectedTokens = tokenizeFunctionSignature(expectedFunctionSignature);\r\n\r\n            for (let i = 0; i < tokens.length; i++) {\r\n                if (tokens[i].str !== expectedTokens[i].str) {\r\n\r\n                    let parseError = \"Function signature does not match the expected signature. \";\r\n                    if (i === 0) {\r\n                        parseError += \"\\nThe function signature should begin with `\" + expectedTokens[i].str + \"` but you have \";\r\n                        if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                            parseError += \"nothing.\";\r\n                        } else {\r\n                            parseError += \"`\" + tokens[i].str + \"`.\";\r\n                        }\r\n                    } else {\r\n                        if (tokens[i] === undefined || tokens[i].str === \"\") {\r\n                            parseError += \"Expected: `\" + expectedTokens[i].str + \"` but got nothing.\";\r\n                        } else {\r\n                            parseError += \"Expected: `\" + expectedTokens[i].str + \"` after `\" + tokens.slice(0, i)\r\n                                .map(t => t.str).join(\" \") + \"` but got: `\" + tokens[i].str + \"`.\";\r\n                        }\r\n                    }\r\n\r\n                    let distance = levenshteinDistance(tokens[i].str, expectedTokens[i].str);\r\n\r\n                    // We also check the levenshtein distance\r\n                    // to see if the user has a typo and put the error on the closest match\r\n                    if (i > missingFunctionError.matchedTokens ||\r\n                        (distance < missingFunctionError.levenshteinDistance && i >= missingFunctionError.matchedTokens)) {\r\n                        missingFunctionError = {\r\n                            returnableError: {\r\n                                testResults: [],\r\n                                returnedResults: [],\r\n                                expectedResults: getExpectedResults(problemData),\r\n                                parseError,\r\n                                errorLine: tokens[i].lineNum,\r\n                                runtimeError: \"\",\r\n                                outputs: [],\r\n                                ranSuccessfully: false\r\n                            },\r\n                            matchedTokens: i,\r\n                            levenshteinDistance: distance\r\n                        }\r\n                    }\r\n                    continue fnLoop;\r\n                }\r\n            }\r\n\r\n            if (tokens.length !== expectedTokens.length) {\r\n                if (tokens.length > missingFunctionError.matchedTokens) {\r\n                    missingFunctionError = {\r\n                        returnableError: {\r\n                            testResults: [],\r\n                            returnedResults: [],\r\n                            expectedResults: getExpectedResults(problemData),\r\n                            parseError: \"Function signature does not match the expected signature. \" +\r\n                                \"Expected: \" + expectedFunctionSignature + \" but got: \" + functionSignature,\r\n                            errorLine: tokens[tokens.length - 1].lineNum,\r\n                            runtimeError: \"\",\r\n                            outputs: [],\r\n                            ranSuccessfully: false\r\n                        },\r\n                        matchedTokens: tokens.length,\r\n                        levenshteinDistance: 100000\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n            foundFunction = true;\r\n            break;\r\n        }\r\n\r\n        if (!foundFunction) {\r\n            return missingFunctionError.returnableError;\r\n        }\r\n    }\r\n\r\n    // We need to look for all the loops (for, while, do-while) and insert code to count the number of iterations.\r\n    // If the number of iterations exceeds 10000, we'll stop the code and return an error.\r\n    // This is to prevent infinite loops.\r\n\r\n    function findLoops(code: string) {\r\n        const loopRegex = /\\b(for|while|do\\s*while)\\s*\\((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)\\s*\\{/g;\r\n        const loops = [];\r\n        let match;\r\n\r\n        while ((match = loopRegex.exec(code)) !== null) {\r\n            loops.push({\r\n                type: match[1],\r\n                start: match.index,\r\n                end: findLoopEndIndex(code, match.index + match[0].length)\r\n            });\r\n        }\r\n\r\n        return loops;\r\n    }\r\n\r\n    function findLoopEndIndex(code: string, startIndex: number) {\r\n        let level = 1;\r\n        for (let i = startIndex; i < code.length; i++) {\r\n            if (code[i] === '{') {\r\n                level++;\r\n            } else if (code[i] === '}') {\r\n                level--;\r\n                if (level === 0) {\r\n                    return i + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1; // If loop end is not found\r\n    }\r\n\r\n\r\n    let loopCounterExtraLines: number[] = []\r\n\r\n    let loops = findLoops(userCode);\r\n    for (let i = 0; i < loops.length; i++) {\r\n        let loop = loops[i];\r\n        let loopHeaderStart = loop.start;\r\n        let loopHeaderEnd = userCode.indexOf('{', loopHeaderStart) + 1;\r\n\r\n        let loopHeader = userCode.substring(loopHeaderStart, loopHeaderEnd);\r\n        let preLoopCode = userCode.substring(0, loopHeaderStart);\r\n        let postLoopHeader = userCode.substring(loopHeaderEnd);\r\n\r\n        let lineOfCounter = preLoopCode.split('\\n').length;\r\n        let linePastLoopHeader = preLoopCode.split('\\n').length + loopHeader.split('\\n').length;\r\n\r\n        let loopCounterVar = \"loopCounter\" + crypto.randomUUID().replace(/-/g, '');\r\n        let userCodeAddPreLoop = `let ${loopCounterVar} = 0;\\n`;\r\n        let userCodeAddPostLoop = `if (${loopCounterVar}++ > 10000) { throw new Error(\"Infinite loop detected. Execution stopped.\"); }\\n`;\r\n        userCode = preLoopCode + userCodeAddPreLoop + loopHeader + userCodeAddPostLoop + postLoopHeader;\r\n\r\n        loopCounterExtraLines.push(lineOfCounter);\r\n        loopCounterExtraLines.push(linePastLoopHeader);\r\n\r\n        let addedChars = userCodeAddPreLoop.length + userCodeAddPostLoop.length;\r\n        //Adjust the line numbers of the loops\r\n        for (let j = i + 1; j < loops.length; j++) {\r\n            loops[j].start += addedChars;\r\n            loops[j].end += addedChars;\r\n        }\r\n    }\r\n\r\n    let solutionCode = problemData.solutionCode;\r\n    let resultsArrayName = \"results\" + crypto.randomUUID().replace(/-/g, '');\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n    let consoleLogArrayName = \"consoleLog\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${resultsArrayName} = [] || [];\r\nlet ${expectedResultsArrayName} = [] || [];\r\nlet ${consoleLogArrayName} = [] || [];\r\n    `;\r\n\r\n    let userCodeLineNumbersBegin: number[] = [];\r\n\r\n    let userCodeLineNumbersEnd: number[] = [];\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests)\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We need to run that twice:\r\n        //  - Once with the solution code\r\n        //  - Once with the user's code\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                {\r\n${solutionCode}\r\n                    try {\r\n                        expected = ${getResult}\r\n                    } catch (e) {\r\n                        expected = e;\r\n                    }\r\n                }\r\n                {\r\n                const cc = new CaptureConsole();\r\n                cc.start();\r\n                `;\r\n        userCodeLineNumbersBegin.push(codeToRun.split('\\n').length);\r\n        codeToRun += userCode;\r\n        userCodeLineNumbersEnd.push(codeToRun.split('\\n').length);\r\n\r\n        codeToRun += `\r\n                    try {\r\n                        result = ${getResult}\r\n                    } catch (e) {\r\n                        result = e;\r\n                    }\r\n                    cc.stop();\r\n                    ${consoleLogArrayName}.push(cc.getCaptures());\r\n                }\r\n            }\r\n            ${resultsArrayName}.push(result);\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return [${resultsArrayName}, ${expectedResultsArrayName}, ${consoleLogArrayName}];\r\n    `;\r\n\r\n    // eslint-disable-next-line\r\n    let resultsArray: any[] = [];\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n    let consoleLogArray: Log[][] = [];\r\n\r\n\r\n    let testResults = new TestResults();\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(\"CaptureConsole\", codeToRun);\r\n        let out = func(CaptureConsole);\r\n\r\n        resultsArray = out[0];\r\n        expectedResultsArray = out[1];\r\n        consoleLogArray = out[2];\r\n        testResults.ranSuccessfully = true;\r\n    } catch (e) {\r\n        testResults.ranSuccessfully = false;\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        testResults.expectedResults = getExpectedResults(problemData);\r\n        if (e instanceof Error) {\r\n            testResults.errorLine = reformatStackTrace(e, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n            console.log(e.stack);\r\n            testResults.runtimeError = e.stack as string;\r\n        } else {\r\n            testResults.runtimeError = e as string;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Check that we've actually run the test (i.e. we have a result)\r\n        if (i >= expectedResultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(\"Unknown\");\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.outputs.push([]);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        if (i >= resultsArray.length) {\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            testResults.expectedResults.push(expectedResultsArray[i].toString());\r\n            testResults.returnedResults.push(\"Unknown\");\r\n            testResults.outputs.push([]);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        }\r\n\r\n        let result = resultsArray[i];\r\n        let expectedResult = expectedResultsArray[i];\r\n        let log: Log[];\r\n        if (i > problemData.tests.length) {\r\n            log = []; //Don't save console logs for hidden tests\r\n        } else {\r\n            log = consoleLogArray[i];\r\n\r\n        }\r\n\r\n        if (expectedResult instanceof Error) {\r\n            testResults.expectedResults.push(\"Error\");\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.NotRun);\r\n            console.error(\"A test case failed to run the solution: \" + expectedResult);\r\n            console.log(\"Test: \" + combinedTests[i]);\r\n            // TODO: Remove the bottom 2 lines\r\n            console.log(\"Solution: \" + problemData.solutionCode);\r\n            console.log(\"User code: \" + userCode);\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.expectedResults.push(safeToString(expectedResult));\r\n        }\r\n\r\n        let outputArray: string[] = [];\r\n        for (let entry of log) {\r\n            let out = \"\";\r\n            if (entry.function !== \"log\") {\r\n                out = entry.function + \": \";\r\n            }\r\n\r\n            for (let arg of entry.args) {\r\n                if (arg instanceof Error) {\r\n                    reformatStackTrace(arg, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n                }\r\n            }\r\n\r\n            if (entry.args.length > 0) {\r\n                out += util.format(entry.args[0], ...entry.args.slice(1));\r\n            } else {\r\n                out += \"\";\r\n            }\r\n\r\n            outputArray.push(out);\r\n        }\r\n\r\n        testResults.outputs.push(outputArray);\r\n\r\n        if (result instanceof Error) {\r\n            testResults.returnedResults.push(\"Error\");\r\n            testResults.testResults.push(TestResult.Exception);\r\n            // End the stack trace at the user's code\r\n            testResults.errorLine = reformatStackTrace(result, userCodeLineNumbersBegin, userCodeLineNumbersEnd, loopCounterExtraLines);\r\n\r\n            testResults.runtimeError = result.stack as string;\r\n            testResults.ranSuccessfully = false;\r\n            continue;\r\n        } else {\r\n            testResults.returnedResults.push(safeToString(result));\r\n        }\r\n\r\n\r\n        if (safeToString(result) !== safeToString(expectedResult)) {\r\n            testResults.testResults.push(TestResult.Failed);\r\n        } else {\r\n            testResults.testResults.push(TestResult.Passed);\r\n        }\r\n    }\r\n\r\n    return testResults;\r\n}\r\n\r\n\r\nexport function getExpectedResults(problemData: ProblemData): string[] {\r\n    // Parse the solution code and replace the function name with a random name\r\n    let solutionCode = problemData.solutionCode;\r\n    let expectedResultsArrayName = \"expectedResults\" + crypto.randomUUID().replace(/-/g, '');\r\n\r\n    let codeToRun = `\r\nlet ${expectedResultsArrayName} = [] || [];\r\n    \r\n${solutionCode}\r\n    `;\r\n\r\n    let combinedTests = problemData.tests.concat(problemData.hiddenTests);\r\n\r\n    for (let i = 0; i < combinedTests.length; i++) {\r\n        // Split out everything except the last line of the test case\r\n        // The result is the output of the last line\r\n        // We'll then compare the results\r\n        let testFull = combinedTests[i];\r\n        let testSplitByLines = testFull.test.split('\\n');\r\n        let setupCode = testSplitByLines.slice(0, testSplitByLines.length - 1).join('\\n');\r\n        let getResult = testSplitByLines[testSplitByLines.length - 1];\r\n\r\n        codeToRun += `\r\n        {\r\n            let expected;\r\n            let result;\r\n            {\r\n                ${setupCode}\r\n                try {\r\n                    expected = ${getResult}\r\n                } catch (e) {\r\n                    expected = e;\r\n                }\r\n            }\r\n            ${expectedResultsArrayName}.push(expected);\r\n        }\r\n        `;\r\n    }\r\n\r\n    codeToRun += `\r\n    return ${expectedResultsArrayName}\r\n    `;\r\n    // eslint-disable-next-line\r\n    let expectedResultsArray: any[] = [];\r\n\r\n    try {\r\n        // eslint-disable-next-line\r\n        let func = Function(codeToRun);\r\n        expectedResultsArray = func();\r\n    } catch (e: any) {\r\n        console.error(\"Failed to run the solution: \" + e);\r\n        console.log(\"Solution: \" + problemData.solutionCode);\r\n        return [];\r\n    }\r\n\r\n    return expectedResultsArray.map(result => safeToString(result));\r\n}\r\n\r\nconst levenshteinDistance = (s: string, t: string) => {\r\n    if (!s.length) return t.length;\r\n    if (!t.length) return s.length;\r\n    const arr = [];\r\n    for (let i = 0; i <= t.length; i++) {\r\n        arr[i] = [i];\r\n        for (let j = 1; j <= s.length; j++) {\r\n            arr[i][j] =\r\n                i === 0\r\n                    ? j\r\n                    : Math.min(\r\n                        arr[i - 1][j] + 1,\r\n                        arr[i][j - 1] + 1,\r\n                        arr[i - 1][j - 1] + (s[j - 1] === t[i - 1] ? 0 : 1)\r\n                    );\r\n        }\r\n    }\r\n    return arr[t.length][s.length];\r\n};","import {Marked} from \"marked\";\r\nimport {markedHighlight} from \"marked-highlight\";\r\nimport hljs from \"highlight.js/lib/common\";\r\nimport React, {lazy, Suspense, useEffect, useState} from \"react\";\r\nimport DOMPurify from \"dompurify\";\r\nimport {HelpBoxAndButton, NEXT_HELP_TIME} from \"./Help\";\r\nimport {useParams} from \"react-router-dom\";\r\nimport 'katex/dist/katex.min.css';\r\nimport {getUserName} from \"../auth/AuthHelper\";\r\nimport {getExpectedResults, TestResult, TestResults, testUserCode} from \"./CodeRunner\";\r\nimport {Button, Popover, ThemeProvider} from \"@mui/material\";\r\nimport {buttonTheme, mutedButtonTheme} from \"../App\";\r\nimport markedKatex from \"marked-katex-extension\";\r\nimport {parseProblem, ProblemData, TestCase} from \"./ProblemParse\";\r\n\r\nhljs.registerAliases([\"\"], {languageName: \"javascript\"})\r\n\r\nconst Editor = lazy(() => import(\"./Editor\"));\r\nexport const marked = new Marked(\r\n    markedHighlight({\r\n        langPrefix: 'hljs language-',\r\n        highlight(code, lang, info) {\r\n            const language = hljs.getLanguage(lang) ? lang : 'plaintext';\r\n            return hljs.highlight(code, {language}).value;\r\n        }\r\n    })\r\n);\r\n\r\nconst options = {\r\n    throwOnError: false,\r\n    displayMode: false,\r\n};\r\n\r\nmarked.use(markedKatex(options));\r\n\r\nexport function saveUserData(problemData: ProblemData, userData: UserData) {\r\n    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n        console.error(\"User data is being saved with no code\");\r\n    }\r\n\r\n    localStorage.setItem(getStorageKey(problemData.id, getUserName()), JSON.stringify(userData));\r\n}\r\n\r\nfunction getStorageKey(id: string, userName: string | undefined) {\r\n    return \"problem \" + id;\r\n}\r\n\r\nexport default function Problem() {\r\n    const [problemData, setProblemData] = useState(null as unknown as ProblemData);\r\n    const {\"*\": id} = useParams();\r\n    const [userData, setUserData] = useState(null as unknown as UserData);\r\n    const [helpResponse, setHelpResponse] = useState(\"When you press \\\"I'm stuck\\\", the AI tutor will respond here.\");\r\n    const [magicLinksHover, setMagicLinks] = useState({\r\n        anchorEl: null as (React.JSX.Element | null),\r\n        magicLink: \"\",\r\n        highlight: true\r\n    })\r\n\r\n    function onCodeSubmit() {\r\n        return onSubmission(problemData, userData, setUserData);\r\n    }\r\n\r\n    let normalizedId = id?.toLowerCase();\r\n    normalizedId?.trim()\r\n    if (normalizedId?.startsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(1)\r\n    }\r\n\r\n    if (normalizedId?.endsWith(\"/\")) {\r\n        normalizedId = normalizedId.substring(0, normalizedId.length - 1)\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (normalizedId !== undefined) {\r\n            fetch(process.env.PUBLIC_URL + \"/problems/\" + normalizedId + \".md\")\r\n                .then(async r => {\r\n                    let text = await r.text()\r\n                    if (!r.ok || !text.startsWith(\"#\")) {\r\n                        throw new Error(\"Failed to fetch problem data\");\r\n                    } else {\r\n                        return text;\r\n                    }\r\n                })\r\n                .then(async text => {\r\n                    // @ts-ignore - we've check that the id isn't undefined\r\n                    let problemData = parseProblem(text, normalizedId);\r\n                    let userData = getUserData(normalizedId, getUserName());\r\n\r\n                    // set the template data if the user has not saved any data\r\n                    if (userData.currentCode === null || userData.currentCode === \"\" || userData.currentCode === undefined) {\r\n                        console.log(\"First time loading problem, setting template data\");\r\n                        if (problemData.displayAbove !== \"\" && problemData.displayBelow !== \"\") {\r\n                            userData.currentCode = problemData.displayAbove + \"\\n\\t\\n\" + problemData.displayBelow;\r\n                        }\r\n                    }\r\n\r\n                    if (userData.testResults === undefined || userData.testResults === null || userData.testResults.expectedResults.length === 0) {\r\n                        console.log(\"First time loading problem, getting expected results\");\r\n                        userData.testResults = new TestResults()\r\n                        userData.testResults.expectedResults = getExpectedResults(problemData);\r\n\r\n                    }\r\n\r\n                    setProblemData(problemData);\r\n                    setUserData(userData);\r\n                })\r\n                .catch(e => {\r\n                    console.error(e);\r\n                    let problemData = new ProblemData();\r\n                    problemData.title = \"Failed to load problem \" + normalizedId;\r\n                    setProblemData(problemData);\r\n                });\r\n        }\r\n    }, [normalizedId]);\r\n\r\n\r\n    if (problemData === null || userData === null) {\r\n        if (problemData != null && problemData.title !== undefined && problemData.title.startsWith(\"Failed to load problem\") && normalizedId !== undefined) {\r\n            return <div>Failed to load problem {normalizedId}</div>;\r\n        }\r\n        if (normalizedId !== undefined) {\r\n            return <div>Loading...</div>;\r\n        } else {\r\n            return <div>A problem wasn't specified</div>;\r\n        }\r\n    }\r\n\r\n    let hljsLang = problemData.codeLang;\r\n    if (hljsLang === \"\") {\r\n        hljsLang = \"plaintext\";\r\n    }\r\n\r\n    let descParsed = DOMPurify.sanitize(marked.parse(problemData.preProblemDescription + \"\\n\\n\" + problemData.description) as string);\r\n\r\n    const handlePopoverOpen = (event: React.MouseEvent<HTMLElement>, magicLink: string, highlight = true) => {\r\n        setMagicLinks({\r\n            anchorEl: event.currentTarget as unknown as React.JSX.Element,\r\n            magicLink: magicLink,\r\n            highlight: highlight\r\n        });\r\n    };\r\n\r\n    const handlePopoverClose = () => {\r\n        setMagicLinks({\r\n            anchorEl: null,\r\n            magicLink: magicLinksHover.magicLink,\r\n            highlight: magicLinksHover.highlight\r\n        });\r\n    };\r\n\r\n    const open = Boolean(magicLinksHover.anchorEl);\r\n\r\n\r\n    let testsDisplay = [];\r\n\r\n    for (let i = 0; i < problemData.tests.length; i++) {\r\n        testsDisplay.push(getTestElement(problemData.tests, userData.testResults, i,\r\n            handlePopoverOpen, handlePopoverClose));\r\n    }\r\n\r\n    let testsDisplayJSX = <div>There are no visible test cases</div>;\r\n    if (testsDisplay.length > 0) {\r\n        testsDisplayJSX = <ul className=\"\">\r\n            {testsDisplay.map((test, i) => <li key={i}>{test}</li>)}\r\n        </ul>\r\n    }\r\n\r\n\r\n    let hiddenTestText: string;\r\n    if (userData.testResults.testResults.length === 0) {\r\n        hiddenTestText = \"Hidden tests will be run when you submit your code\";\r\n    } else {\r\n        let totalHiddenTests = problemData.hiddenTests.length;\r\n        let hiddenTestsPassed = 0;\r\n        for (let i = 0; i < problemData.hiddenTests.length; i++) {\r\n            if (userData.testResults.testResults[i + problemData.tests.length] === TestResult.Passed) {\r\n                hiddenTestsPassed++;\r\n            }\r\n        }\r\n        hiddenTestText = hiddenTestsPassed + \" / \" + totalHiddenTests + \" hidden tests passed\";\r\n    }\r\n\r\n    // Callback when the user updates their code\r\n    function updateUserCode(value: string) {\r\n        userData.currentCode = value;\r\n        saveUserData(problemData, userData);\r\n    }\r\n\r\n    let errorText: string = \"\"\r\n    let problemSolved = userData.testResults.testResults.every(result => result === TestResult.Passed) &&\r\n        userData.testResults.testResults.length === userData.testResults.expectedResults.length;\r\n\r\n    if (!userData.testResults.ranSuccessfully) {\r\n        if (userData.testResults.parseError !== \"\") {\r\n            errorText += \"We couldn't run your code due to a syntax error on line \" + userData.testResults.errorLine + \".\\n\";\r\n            errorText += indentText(userData.testResults.parseError, 1);\r\n        } else if (userData.testResults.runtimeError !== \"\") {\r\n            errorText += \"Something went wrong trying to run you code\"\r\n            if (userData.testResults.errorLine !== -1) {\r\n                errorText += \" on line \" + userData.testResults.errorLine + \".\\n\";\r\n            } else {\r\n                errorText += \".\\n\";\r\n            }\r\n            errorText += indentText(userData.testResults.runtimeError, 1);\r\n        } else {\r\n            errorText += \"No error message was provided.\"\r\n        }\r\n    }\r\n\r\n    errorText = errorText.replace(/\\n/g, \"<br>\");\r\n    errorText = DOMPurify.sanitize(errorText);\r\n\r\n    let {helpButton, helpBox} =\r\n        HelpBoxAndButton(problemData, setUserData, onCodeSubmit, helpResponse, setHelpResponse);\r\n\r\n    let nextProblem;\r\n    if (problemData.nextProblemId !== \"\" && problemData.nextProblemId.toLowerCase() !== \"nothing\") {\r\n        nextProblem = <ThemeProvider theme={mutedButtonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color={problemSolved ? \"secondary\" : \"primary\"}\r\n                    href={\"/problem/\" + problemData.nextProblemId}\r\n                    className={\"nextProblemButton\"}>\r\n                Next Problem\r\n            </Button>\r\n        </ThemeProvider>\r\n    } else {\r\n        nextProblem = <div/>\r\n    }\r\n\r\n\r\n    let highlightHover;\r\n    if (magicLinksHover.highlight) {\r\n        highlightHover = hljs.highlight(magicLinksHover.magicLink, {language: hljsLang}).value;\r\n    } else {\r\n        highlightHover = magicLinksHover.magicLink;\r\n    }\r\n    let hoverHtml = DOMPurify.sanitize(highlightHover.replace(/\\n/g, \"<br>\"));\r\n\r\n    let helpButtonHtml;\r\n    if (localStorage.getItem(NEXT_HELP_TIME) !== null) {\r\n        helpButtonHtml = <span className=\"ml-1\"\r\n                               onMouseEnter={(e) => {\r\n                                   let timeToNextHelp = parseInt(localStorage.getItem(NEXT_HELP_TIME) as string);\r\n                                   let timeToNextHelpSeconds = Math.ceil((timeToNextHelp - Date.now()) / 1000);\r\n                                   if (timeToNextHelpSeconds > 0) {\r\n                                       handlePopoverOpen(e, \"You can request help again in \" + timeToNextHelpSeconds + \" seconds\", false)\r\n                                   }\r\n                               }}\r\n                               onMouseLeave={handlePopoverClose}>\r\n                        {helpButton}\r\n                    </span>\r\n    } else {\r\n        helpButtonHtml = <span className=\"ml-1\">{helpButton}</span>\r\n    }\r\n\r\n\r\n    return (\r\n        <div className=\"ml-5 flex-row\">\r\n            <div className=\"text-7xl font-bold pt-1 pb-5\">{problemData.title}</div>\r\n            <div className=\"w-1/2\" dangerouslySetInnerHTML={{__html: descParsed}}/>\r\n            <div className=\"flex flex-row justify-between h-auto pt-2\">\r\n                <div className=\"w-1/2 h-[calc(100vh*0.80)]\">\r\n                    <Suspense fallback={<div className={\"italic text-gray-300\"}>The Editor is loading...</div>}>\r\n                        <Editor\r\n                            lang={problemData.codeLang}\r\n                            onChange={(value) => updateUserCode(value)}\r\n                            defaultValue={userData.currentCode}\r\n                        />\r\n                    </Suspense>\r\n\r\n                    <div className=\"pt-2\">\r\n                        {nextProblem}\r\n                    </div>\r\n                </div>\r\n                <div className=\"w-1/2 pl-4 pr-4\">\r\n                    <div className=\"text-3xl font-bold w-1/3\"> Tests</div>\r\n                    {testsDisplayJSX}\r\n                    <p className=\"Problem-hidden-tests\">\r\n                        {hiddenTestText}\r\n                    </p>\r\n                    <SubmitButton onClick={onCodeSubmit}/>\r\n                    {helpButtonHtml}\r\n                    <div className=\"text-error-red\" dangerouslySetInnerHTML={{__html: errorText}}/>\r\n                    {helpBox}\r\n                </div>\r\n            </div>\r\n            <Popover\r\n                id=\"mouse-over-popover\"\r\n                sx={{\r\n                    pointerEvents: 'none',\r\n                }}\r\n                open={open}\r\n                anchorEl={magicLinksHover.anchorEl as Element | null}\r\n                anchorOrigin={{\r\n                    vertical: 'bottom',\r\n                    horizontal: 'left',\r\n                }}\r\n                transformOrigin={{\r\n                    vertical: 'top',\r\n                    horizontal: 'left',\r\n                }}\r\n                onClose={handlePopoverClose}\r\n                disableRestoreFocus\r\n            >\r\n                <div className=\"p-2 bg-basically-black text-[#abb2bf]\"\r\n                     style={{\r\n                         fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\r\n                         whiteSpace: \"pre-wrap\",\r\n                     }}\r\n                     dangerouslySetInnerHTML={{__html: hoverHtml}\r\n                     }/>\r\n            </Popover>\r\n        </div>\r\n    );\r\n}\r\n\r\n/**\r\n * Returns a JSX element for a test case\r\n */\r\nfunction getTestElement(testCases: TestCase[], testResults: TestResults, index: number,\r\n                        handlePopoverOpen: (event: React.MouseEvent<HTMLElement>, magicLink: string) => void,\r\n                        handlePopoverClose: () => void) {\r\n    let result = testResults.testResults[index];\r\n    let resultText = result === undefined ? \"Not Run\" : result.toString();\r\n    if (result === TestResult.Failed) {\r\n        resultText += \" (Returned: \" + testResults.returnedResults[index] + \")\";\r\n    }\r\n\r\n    let bgColor = result === TestResult.Passed ? \"bg-test-passed\" : \"bg-test-failed\";\r\n\r\n    class MagicLink {\r\n        text: string;\r\n        link: string;\r\n\r\n        constructor(text: string, link: string) {\r\n            this.text = text;\r\n            this.link = link;\r\n        }\r\n    }\r\n\r\n    let testStringPart: (string | MagicLink)[] = [];\r\n\r\n    let testString = testCases[index].display;\r\n\r\n    for (const entries of testCases[index].magicLinks.values()) {\r\n        let key = entries.key;\r\n        let value = entries.value;\r\n\r\n        let index = testString.indexOf(key);\r\n\r\n        if (index === -1) {\r\n            console.error(\"Failed to find magic link in test string: \" + key);\r\n            continue;\r\n        }\r\n        if (index > 0) {\r\n            testStringPart.push(testString.substring(0, index));\r\n            testString = testString.substring(index);\r\n        }\r\n        testStringPart.push(new MagicLink(key, value));\r\n        testString = testString.substring(key.length);\r\n    }\r\n\r\n    testStringPart.push(testString);\r\n    let shouldDisplayConsole = testResults.outputs[index] !== undefined && testResults.outputs[index].length > 0;\r\n\r\n\r\n    let resultSpan;\r\n    if (shouldDisplayConsole) {\r\n        let consoleOutput = shouldDisplayConsole ? \"Console Output: \\n\" + testResults.outputs[index].join(\"\\n\") : \"\";\r\n\r\n        resultSpan =\r\n            <span className={\"underline decoration-gray-600 underline-offset-2\"}\r\n                  onMouseEnter={(e) => handlePopoverOpen(e, consoleOutput)}\r\n                  onMouseLeave={handlePopoverClose}>\r\n            {testResults.expectedResults[index]} : {resultText}\r\n        </span>\r\n    } else {\r\n        resultSpan = <span>{testResults.expectedResults[index]} : {resultText}</span>\r\n    }\r\n\r\n\r\n    let div = <div className={\"mb-2 text-black font-bold pl-1 \" + bgColor}>\r\n        {testStringPart.map((part, i) => {\r\n            if (part instanceof MagicLink) {\r\n                return <span key={i} className={\"text-purple-800 underline\"}\r\n                             onMouseEnter={(e) => handlePopoverOpen(e, part.text + \" = \" + part.link)}\r\n                             onMouseLeave={handlePopoverClose}>{part.text}</span>\r\n            } else {\r\n                return <span key={i}>{part}</span>\r\n            }\r\n        })}\r\n        <span>\r\n            {\" ➔ \"}\r\n        </span>\r\n        {resultSpan}\r\n    </div>\r\n\r\n\r\n    return (\r\n        div\r\n    );\r\n}\r\n\r\n/**\r\n * Returns the text indented by a number of tabs\r\n */\r\nfunction indentText(text: string, indent: number) {\r\n    let indentText = \"<span style='margin-left: \" + (indent * 2) + \"em'> </span>\";\r\n\r\n    return text.split(\"\\n\").map(line => indentText + line).join(\"\\n\");\r\n}\r\n\r\nexport class UserData {\r\n    history: string[] = [];\r\n    requestHelpHistory: string[] = [];\r\n    testResults: TestResults = new TestResults();\r\n    lastUpdated: Date = new Date();\r\n    currentCode: string = null as unknown as string;\r\n    aiRememberResponse: string[] = [];\r\n\r\n    constructor(history: string[] = [], requestHelpHistory: string[] = [], testResults: TestResults = new TestResults(), lastUpdated: Date = new Date(), currentCode: string = \"\", aiRememberResponse: string[] = []) {\r\n        this.history = history;\r\n        this.testResults = testResults;\r\n        this.requestHelpHistory = requestHelpHistory;\r\n        this.lastUpdated = lastUpdated;\r\n        this.currentCode = currentCode;\r\n        this.aiRememberResponse = aiRememberResponse;\r\n    }\r\n}\r\n\r\n/**\r\n * Loads the user data from local storage\r\n * @param id The id of the problem\r\n * @param userName The username of the user\r\n */\r\nfunction getUserData(id: string | undefined, userName: string | undefined) {\r\n    if (id === undefined) {\r\n        console.error(\"No problem id was specified, so no user data could be retrieved.\");\r\n        return new UserData();\r\n    }\r\n    let userData = localStorage.getItem(getStorageKey(id, userName));\r\n    if (userData === null) {\r\n        // try to get the data without the username\r\n        userData = localStorage.getItem(getStorageKey(id, undefined));\r\n        if (userData !== null) {\r\n            console.log(\"Got user data without username\");\r\n        }\r\n    }\r\n    if (userData === null) {\r\n        return new UserData();\r\n    }\r\n\r\n    return JSON.parse(userData) as UserData;\r\n}\r\n\r\nfunction SubmitButton({onClick}: { onClick: () => void }) {\r\n    return (\r\n        <ThemeProvider theme={buttonTheme}>\r\n            <Button variant=\"contained\"\r\n                    color=\"primary\"\r\n                    onClick={onClick}\r\n                    className={\"submitButton\"}\r\n            >\r\n                Test Code\r\n            </Button>\r\n        </ThemeProvider>\r\n    );\r\n}\r\n\r\n\r\nfunction onSubmission(problemData: ProblemData, userData: UserData, setUserData: (data: UserData) => void) {\r\n    if (userData.history.length === 0) {\r\n        // First submission\r\n        userData.history.push(userData.currentCode);\r\n    } else {\r\n        let lastSubmission = userData.history[userData.history.length - 1];\r\n        if (lastSubmission !== userData.currentCode) {\r\n            userData.history.push(userData.currentCode);\r\n        }\r\n    }\r\n\r\n    userData.lastUpdated = new Date();\r\n\r\n    let testResults = testUserCode(userData, problemData);\r\n\r\n    let newUserData = new UserData(\r\n        userData.history,\r\n        userData.requestHelpHistory,\r\n        testResults,\r\n        new Date(),\r\n        userData.currentCode,\r\n        userData.aiRememberResponse\r\n    )\r\n    setUserData(newUserData);\r\n    saveUserData(problemData, newUserData);\r\n    return newUserData;\r\n}"],"names":["ProblemData","constructor","id","title","preProblemDescription","description","tests","hiddenTests","displayAbove","displayBelow","solution","solutionCode","codeLang","nextProblemId","KeyValue","key","value","this","extractTestCases","tokens","length","absorbWhitespace","type","testString","shift","text","trim","split","flatMap","s","functionCall","indexBeginParen","indexOf","indexEndParen","i","console","error","params","substring","map","repeatTimes","displayAs","endsWith","magicLinks","param","match","RegExp","concat","undefined","index","bracketCount","curlyCount","doubleQuoteCount","singleQuoteCount","backtickCount","c","setKeyValue","metaData","toLowerCase","num","parseInt","isNaN","includes","push","test","display","kvList","kv","removeNextHeading","expectedText","removeTillNextType","heading","Error","LOADING_MESSAGE","NEXT_HELP_TIME","functionHeaderOffset","TestResult","TestResults","testResults","returnedResults","expectedResults","parseError","errorLine","runtimeError","outputs","ranSuccessfully","StringLineNum","str","lineNum","CaptureConsole","require","tokenizeFunctionSignature","signature","tokenChars","bufferStartIndex","filter","token","reformatStackTrace","result","userCodeLineNumbersBegin","userCodeLineNumbersEnd","addedLines","stackTrace","stack","stackTraceLines","j","thisLine","startsWith","slice","regex","replace","matches","lineNumber","userCodeLineNumberBegin","userCodeLineNumberEnd","newLineNumber","lineNumberOffset","columnNumber","newLine","join","safeToString","expectedResult","toString","getExpectedResults","problemData","expectedResultsArrayName","crypto","randomUUID","codeToRun","combinedTests","testSplitByLines","setupCode","getResult","expectedResultsArray","Function","func","e","log","levenshteinDistance","t","arr","Math","min","hljs","registerAliases","languageName","Editor","lazy","marked","Marked","markedHighlight","langPrefix","highlight","code","lang","info","language","getLanguage","saveUserData","userData","currentCode","localStorage","setItem","getStorageKey","getUserName","JSON","stringify","userName","Problem","_normalizedId","_normalizedId2","_normalizedId3","setProblemData","useState","useParams","setUserData","helpResponse","setHelpResponse","magicLinksHover","setMagicLinks","anchorEl","magicLink","onCodeSubmit","history","lastUpdated","Date","ast","userCode","acorn","ecmaVersion","locations","SyntaxError","message","pos","loc","line","missingFunctionError","returnableError","matchedTokens","foundFunction","fnLoop","body","functionSignature","start","end","expectedFunctionSignature","expectedTokens","distance","findLoopEndIndex","startIndex","level","loopCounterExtraLines","loops","loopRegex","exec","findLoops","loopHeaderStart","loopHeaderEnd","loopHeader","preLoopCode","postLoopHeader","lineOfCounter","linePastLoopHeader","loopCounterVar","userCodeAddPreLoop","userCodeAddPostLoop","addedChars","resultsArrayName","consoleLogArrayName","resultsArray","consoleLogArray","out","NotRun","outputArray","entry","function","arg","args","util","format","Exception","Failed","Passed","testUserCode","newUserData","UserData","requestHelpHistory","aiRememberResponse","onSubmission","normalizedId","useEffect","fetch","then","async","r","ok","lexer","depth","raw","problem","splitProblem","parseProblem","getItem","parse","getUserData","catch","_jsxs","children","_jsx","hljsLang","descParsed","DOMPurify","handlePopoverOpen","event","arguments","currentTarget","handlePopoverClose","open","Boolean","testsDisplay","getTestElement","hiddenTestText","testsDisplayJSX","className","totalHiddenTests","hiddenTestsPassed","errorText","problemSolved","every","indentText","nextProblem","highlightHover","helpButton","helpBox","runTests","response","setResponse","button","ThemeProvider","theme","buttonTheme","Button","variant","color","onClick","setAttribute","isLoggedIn","getToken","target","method","headers","accept","json","expire_logins","expireToken","logIn","status","now","wait_time","Promise","resolve","setTimeout","removeAttribute","rememberingResponse","dangerouslySetInnerHTML","__html","HelpBoxAndButton","mutedButtonTheme","href","helpButtonHtml","hoverHtml","onMouseEnter","timeToNextHelp","timeToNextHelpSeconds","ceil","onMouseLeave","Suspense","fallback","onChange","updateUserCode","defaultValue","SubmitButton","Popover","sx","pointerEvents","anchorOrigin","vertical","horizontal","transformOrigin","onClose","disableRestoreFocus","style","fontFamily","whiteSpace","testCases","resultText","bgColor","MagicLink","link","testStringPart","entries","values","resultSpan","shouldDisplayConsole","consoleOutput","part","indent","use","markedKatex","throwOnError","displayMode","_ref"],"sourceRoot":""}